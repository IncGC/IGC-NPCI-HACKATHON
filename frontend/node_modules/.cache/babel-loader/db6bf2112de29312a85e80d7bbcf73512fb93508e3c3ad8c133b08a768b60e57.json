{"ast":null,"code":"import { useFloating as useFloating$1, offset, detectOverflow, getOverflowAncestors } from '@floating-ui/react-dom';\nexport * from '@floating-ui/react-dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect, useRef } from 'react';\nimport { createPortal, flushSync } from 'react-dom';\nimport { tabbable } from 'tabbable';\nimport { hideOthers } from 'aria-hidden';\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach(handler => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n    off(event, listener) {\n      map.set(event, (map.get(event) || []).filter(l => l !== listener));\n    }\n  };\n}\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = () => \"floating-ui-\" + count++;\nfunction useFloatingId() {\n  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : undefined);\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  React.useEffect(() => {\n    if (!serverHandoffComplete) {\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id;\n} // `toString()` prevents bundlers from trying to `import { useId } from 'react'`\n\nconst useReactId = React[/*#__PURE__*/'useId'.toString()];\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/useId\n */\n\nconst useId = useReactId != null ? useReactId : useFloatingId;\nconst FloatingNodeContext = /*#__PURE__*/React.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/React.createContext(null);\nconst useFloatingParentNodeId = () => {\n  var _React$useContext$id, _React$useContext;\n  return (_React$useContext$id = (_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) != null ? _React$useContext$id : null;\n};\nconst useFloatingTree = () => React.useContext(FloatingTreeContext);\n/**\n * Registers a node into the floating tree, returning its id.\n */\n\nconst useFloatingNodeId = customParentId => {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null ? void 0 : tree.addNode(node);\n    return () => {\n      tree == null ? void 0 : tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n};\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\n\nconst FloatingNode = _ref => {\n  let {\n    children,\n    id\n  } = _ref;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/React.createElement(FloatingNodeContext.Provider, {\n    value: React.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n};\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM (i.e. portalled to a common node, rather than their\n * respective parent).\n * @see https://floating-ui.com/docs/FloatingTree\n */\n\nconst FloatingTree = _ref2 => {\n  let {\n    children\n  } = _ref2;\n  const nodesRef = React.useRef([]);\n  const addNode = React.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = React.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = React.useState(() => createPubSub())[0];\n  return /*#__PURE__*/React.createElement(FloatingTreeContext.Provider, {\n    value: React.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [nodesRef, addNode, removeNode, events])\n  }, children);\n};\nfunction getDocument(floating) {\n  var _floating$ownerDocume;\n  return (_floating$ownerDocume = floating == null ? void 0 : floating.ownerDocument) != null ? _floating$ownerDocume : document;\n}\n\n// Avoid Chrome DevTools blue warning\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(_ref => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(' ');\n  }\n  return navigator.userAgent;\n}\nfunction getWindow(value) {\n  var _getDocument$defaultV;\n  return (_getDocument$defaultV = getDocument(value).defaultView) != null ? _getDocument$defaultV : window;\n}\nfunction isElement(value) {\n  return value ? value instanceof getWindow(value).Element : false;\n}\nfunction isHTMLElement(value) {\n  return value ? value instanceof getWindow(value).HTMLElement : false;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n} // License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\n\nfunction isVirtualClick(event) {\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n  const androidRe = /Android/i;\n  if ((androidRe.test(getPlatform()) || androidRe.test(getUserAgent())) && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n  return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n  return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType !== 'mouse' ||\n  // iOS VoiceOver returns 0.333â€¢ for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;\n}\nfunction isSafari() {\n  // Chrome DevTools does not complain about navigator.vendor\n  return /apple/i.test(navigator.vendor);\n}\nfunction isMac() {\n  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n}\n\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = React[/*#__PURE__*/'useInsertionEffect'.toString()];\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\nfunction useEvent(callback) {\n  const ref = React.useRef(() => {\n    if (process.env.NODE_ENV !== \"production\") {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\nfunction useFloating(_temp) {\n  let {\n    open = false,\n    onOpenChange: unstable_onOpenChange,\n    whileElementsMounted,\n    placement,\n    middleware,\n    strategy,\n    nodeId\n  } = _temp === void 0 ? {} : _temp;\n  const [domReference, setDomReference] = React.useState(null);\n  const tree = useFloatingTree();\n  const domReferenceRef = React.useRef(null);\n  const dataRef = React.useRef({});\n  const events = React.useState(() => createPubSub())[0];\n  const position = useFloating$1({\n    placement,\n    middleware,\n    strategy,\n    whileElementsMounted\n  });\n  const onOpenChange = useEvent(unstable_onOpenChange);\n  const refs = React.useMemo(() => ({\n    ...position.refs,\n    domReference: domReferenceRef\n  }), [position.refs]);\n  const context = React.useMemo(() => ({\n    ...position,\n    refs,\n    dataRef,\n    nodeId,\n    events,\n    open,\n    onOpenChange,\n    _: {\n      domReference\n    }\n  }), [position, nodeId, events, open, onOpenChange, refs, domReference]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  const {\n    reference\n  } = position;\n  const setReference = React.useCallback(node => {\n    if (isElement(node) || node === null) {\n      context.refs.domReference.current = node;\n      setDomReference(node);\n    }\n    reference(node);\n  }, [reference, context.refs]);\n  return React.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    reference: setReference\n  }), [position, refs, context, setReference]);\n}\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  return {\n    ...(elementKey === 'floating' && {\n      tabIndex: -1\n    }),\n    ...userProps,\n    ...propsList.map(value => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n      Object.entries(props).forEach(_ref => {\n        let [key, value] = _ref;\n        if (key.indexOf('on') === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n          if (typeof value === 'function') {\n            var _map$get;\n            (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);\n            acc[key] = function () {\n              var _map$get2;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.forEach(fn => fn(...args));\n            };\n          }\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\nconst useInteractions = function (propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n\n  // The dependencies are a dynamic array, so we can't use the linter's\n  // suggestion to add it to the deps array.\n  const deps = propsList;\n  const getReferenceProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getFloatingProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getItemProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  return React.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n};\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    do {\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore\n\n      next = next.parentNode || next.host;\n    } while (next);\n  } // Give up, the result is false\n\n  return false;\n}\nfunction getChildren(nodes, id) {\n  var _nodes$filter;\n  let allChildren = (_nodes$filter = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  })) != null ? _nodes$filter : [];\n  let currentChildren = allChildren;\n  while (currentChildren.length) {\n    var _nodes$filter2;\n    currentChildren = (_nodes$filter2 = nodes.filter(node => {\n      var _currentChildren;\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    })) != null ? _nodes$filter2 : [];\n    allChildren = allChildren.concat(currentChildren);\n  }\n  return allChildren;\n}\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  } // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n\n  return event.target;\n}\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\nfunction safePolygon(_temp) {\n  let {\n    restMs = 0,\n    buffer = 0.5,\n    blockPointerEvents = true,\n    debug = null\n  } = _temp === void 0 ? {} : _temp;\n  let timeoutId;\n  let polygonIsDestroyed = false;\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      refs,\n      onClose,\n      nodeId,\n      tree,\n      leave = false\n    } = _ref;\n    return function onMouseMove(event) {\n      clearTimeout(timeoutId);\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const target = getTarget(event); // If the pointer is over the reference, there is no need to run the logic\n\n      if (event.type === 'mousemove' && contains(refs.domReference.current, target)) {\n        return;\n      } // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n\n      if (event.type === 'mouseleave' && isElement(event.relatedTarget) && contains(refs.floating.current, event.relatedTarget)) {\n        return;\n      } // If any nested child is open, abort.\n\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      } // The cursor landed, so we destroy the polygon logic\n\n      if (contains(refs.floating.current, target) && !leave) {\n        polygonIsDestroyed = true;\n        return;\n      }\n      if (!refs.domReference.current || !refs.floating.current || placement == null || x == null || y == null) {\n        return;\n      }\n      const refRect = refs.domReference.current.getBoundingClientRect();\n      const rect = refs.floating.current.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2; // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      } // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n\n      switch (side) {\n        case 'top':\n          if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= refRect.top + 1) {\n            return;\n          }\n          break;\n        case 'bottom':\n          if (clientX >= rect.left && clientX <= rect.right && clientY >= refRect.bottom - 1 && clientY <= rect.bottom) {\n            return;\n          }\n          break;\n        case 'left':\n          if (clientX >= rect.left && clientX <= refRect.left + 1 && clientY >= rect.top && clientY <= rect.bottom) {\n            return;\n          }\n          break;\n        case 'right':\n          if (clientX >= refRect.right - 1 && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {\n            return;\n          }\n          break;\n      }\n      if (polygonIsDestroyed) {\n        return close();\n      }\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        const isFloatingWider = rect.width > refRect.width;\n        const isFloatingTaller = rect.height > refRect.height;\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n      const poly = getPolygon([x, y]);\n      if (process.env.NODE_ENV !== \"production\") {\n        debug == null ? void 0 : debug(poly.slice(0, 4).join(', '));\n      }\n      if (!isPointInPolygon([clientX, clientY], poly)) {\n        close();\n      } else if (restMs) {\n        timeoutId = setTimeout(onClose, restMs);\n      }\n    };\n  };\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nlet activeElement$1;\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n  if (event.key === 'Tab') {\n    activeElement$1 = event.target;\n    clearTimeout(timeoutId);\n  }\n}\nfunction isTabFocus(event) {\n  const result = activeElement$1 === event.relatedTarget;\n  activeElement$1 = event.relatedTarget;\n  clearTimeout(timeoutId);\n  return result;\n}\nconst FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref) {\n  const onFocus = useEvent(props.onFocus);\n  const [role, setRole] = React.useState();\n  index(() => {\n    if (isSafari()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n    document.addEventListener('keydown', setActiveElementOnTab);\n    return () => {\n      document.removeEventListener('keydown', setActiveElementOnTab);\n    };\n  }, []);\n  return /*#__PURE__*/React.createElement(\"span\", _extends({}, props, {\n    ref: ref,\n    tabIndex: 0 // Role is only for VoiceOver\n    ,\n\n    role: role,\n    \"aria-hidden\": role ? undefined : true,\n    \"data-floating-ui-focus-guard\": \"\",\n    style: HIDDEN_STYLES,\n    onFocus: event => {\n      if (isSafari() && isMac() && !isTabFocus(event)) {\n        // On macOS we need to wait a little bit before moving\n        // focus again.\n        event.persist();\n        timeoutId = window.setTimeout(() => {\n          onFocus(event);\n        }, 50);\n      } else {\n        onFocus(event);\n      }\n    }\n  }));\n});\n\n/**\n * Find the real active element. Traverses into shadowRoots.\n */\nfunction activeElement(doc) {\n  let activeElement = doc.activeElement;\n  while (((_activeElement = activeElement) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {\n    var _activeElement, _activeElement$shadow;\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, direction) {\n  const allTabbable = tabbable(container, getTabbableOptions());\n  if (direction === 'prev') {\n    allTabbable.reverse();\n  }\n  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));\n  const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n  return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n  return getTabbableIn(document.body, 'next');\n}\nfunction getPreviousTabbable() {\n  return getTabbableIn(document.body, 'prev');\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = tabbable(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    var _element$getAttribute;\n    element.dataset.tabindex = (_element$getAttribute = element.getAttribute('tabindex')) != null ? _element$getAttribute : '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\nconst PortalContext = /*#__PURE__*/React.createContext(null);\nconst useFloatingPortalNode = function (_temp) {\n  let {\n    id,\n    enabled = true\n  } = _temp === void 0 ? {} : _temp;\n  const [portalEl, setPortalEl] = React.useState(null);\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    const rootNode = id ? document.getElementById(id) : null;\n    if (rootNode) {\n      rootNode.setAttribute('data-floating-ui-portal', '');\n      setPortalEl(rootNode);\n    } else {\n      const newPortalEl = document.createElement('div');\n      newPortalEl.id = id || uniqueId;\n      newPortalEl.setAttribute('data-floating-ui-portal', '');\n      setPortalEl(newPortalEl);\n      const container = (portalContext == null ? void 0 : portalContext.portalNode) || document.body;\n      container.appendChild(newPortalEl);\n      return () => {\n        container.removeChild(newPortalEl);\n      };\n    }\n  }, [id, portalContext, uniqueId, enabled]);\n  return portalEl;\n};\n/**\n * Portals your floating element outside of the main app node.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\n\nconst FloatingPortal = _ref => {\n  let {\n    children,\n    id,\n    root = null,\n    preserveTabOrder = true\n  } = _ref;\n  const portalNode = useFloatingPortalNode({\n    id,\n    enabled: !root\n  });\n  const [focusManagerState, setFocusManagerState] = React.useState(null);\n  const beforeOutsideRef = React.useRef(null);\n  const afterOutsideRef = React.useRef(null);\n  const beforeInsideRef = React.useRef(null);\n  const afterInsideRef = React.useRef(null);\n  const shouldRenderGuards =\n  // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState &&\n  // Guards are only for non-modal focus management.\n  !focusManagerState.modal && !!(root || portalNode) && preserveTabOrder; // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n\n  React.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n      return;\n    } // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n\n    function onFocus(event) {\n      if (portalNode && isOutsideEvent(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n        manageFocus(portalNode);\n      }\n    } // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);\n  return /*#__PURE__*/React.createElement(PortalContext.Provider, {\n    value: React.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode])\n  }, shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    ref: beforeOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _beforeInsideRef$curr;\n        (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();\n      } else {\n        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        prevTabbable == null ? void 0 : prevTabbable.focus();\n      }\n    }\n  }), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-owns\": portalNode.id,\n    style: HIDDEN_STYLES\n  }), root ? /*#__PURE__*/createPortal(children, root) : portalNode ? /*#__PURE__*/createPortal(children, portalNode) : null, shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    ref: afterOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _afterInsideRef$curre;\n        (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();\n      } else {\n        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        nextTabbable == null ? void 0 : nextTabbable.focus();\n        focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false);\n      }\n    }\n  }));\n};\nconst usePortalContext = () => React.useContext(PortalContext);\nconst identifier = 'data-floating-ui-scroll-lock';\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\n\nconst FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(_ref, ref) {\n  let {\n    lockScroll = false,\n    ...rest\n  } = _ref;\n  index(() => {\n    var _window$visualViewpor, _window$visualViewpor2, _window$visualViewpor3, _window$visualViewpor4;\n    if (!lockScroll) {\n      return;\n    }\n    const alreadyLocked = document.body.hasAttribute(identifier);\n    if (alreadyLocked) {\n      return;\n    }\n    document.body.setAttribute(identifier, ''); // RTL <body> scrollbar\n\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth; // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n\n    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {\n      Object.assign(document.body.style, {\n        overflow: 'hidden',\n        [paddingProp]: scrollbarWidth + \"px\"\n      });\n      return () => {\n        document.body.removeAttribute(identifier);\n        Object.assign(document.body.style, {\n          overflow: '',\n          [paddingProp]: ''\n        });\n      };\n    } // iOS 12 does not support `visuaViewport`.\n\n    const offsetLeft = (_window$visualViewpor = (_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetLeft) != null ? _window$visualViewpor : 0;\n    const offsetTop = (_window$visualViewpor3 = (_window$visualViewpor4 = window.visualViewport) == null ? void 0 : _window$visualViewpor4.offsetTop) != null ? _window$visualViewpor3 : 0;\n    const scrollX = window.pageXOffset;\n    const scrollY = window.pageYOffset;\n    Object.assign(document.body.style, {\n      position: 'fixed',\n      overflow: 'hidden',\n      top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n      left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n      right: '0',\n      [paddingProp]: scrollbarWidth + \"px\"\n    });\n    return () => {\n      Object.assign(document.body.style, {\n        position: '',\n        overflow: '',\n        top: '',\n        left: '',\n        right: '',\n        [paddingProp]: ''\n      });\n      document.body.removeAttribute(identifier);\n      window.scrollTo(scrollX, scrollY);\n    };\n  }, [lockScroll]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: {\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...rest.style\n    }\n  }));\n});\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\nfunction useLatestRef(value) {\n  const ref = useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/React.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/React.createElement(\"button\", _extends({}, props, {\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  }));\n});\n\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(_ref) {\n  let {\n    context,\n    children,\n    order = ['content'],\n    guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    modal = true,\n    visuallyHiddenDismiss = false\n  } = _ref;\n  const {\n    refs,\n    nodeId,\n    onOpenChange,\n    events,\n    _: {\n      domReference\n    }\n  } = context;\n  const orderRef = useLatestRef(order);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const [tabbableContentLength, setTabbableContentLength] = React.useState(null); // Controlled by `useListNavigation`.\n\n  const initialFocusControlled = typeof initialFocus === 'number' && initialFocus < 0;\n  const startDismissButtonRef = React.useRef(null);\n  const endDismissButtonRef = React.useRef(null);\n  const preventReturnFocusRef = React.useRef(false);\n  const previouslyFocusedElementRef = React.useRef(null);\n  const insidePortal = portalContext != null; // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n\n  const typeableCombobox = domReference && domReference.getAttribute('role') === 'combobox' && isTypeableElement(domReference);\n  const getTabbableContent = React.useCallback(function (container) {\n    if (container === void 0) {\n      container = refs.floating.current;\n    }\n    return container ? tabbable(container, getTabbableOptions()) : [];\n  }, [refs]);\n  const getTabbableElements = React.useCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (refs.domReference.current && type === 'reference') {\n        return refs.domReference.current;\n      }\n      if (refs.floating.current && type === 'floating') {\n        return refs.floating.current;\n      }\n      return content;\n    }).filter(Boolean).flat();\n  }, [orderRef, refs, getTabbableContent]);\n  React.useEffect(() => {\n    if (!modal) {\n      return;\n    }\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if (getTabbableContent().length === 0 && !typeableCombobox) {\n          stopEvent(event);\n        }\n        const els = getTabbableElements();\n        const target = getTarget(event);\n        if (orderRef.current[0] === 'reference' && target === refs.domReference.current) {\n          stopEvent(event);\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n        if (orderRef.current[1] === 'floating' && target === refs.floating.current && event.shiftKey) {\n          stopEvent(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n    const doc = getDocument(refs.floating.current);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [modal, orderRef, refs, typeableCombobox, getTabbableContent, getTabbableElements]);\n  React.useEffect(() => {\n    var _portalContext$portal, _portalContext$portal2;\n    const floating = refs.floating.current;\n    const reference = refs.domReference.current; // Don't hide portals nested within the parent portal.\n\n    const portalNodes = Array.from((_portalContext$portal = portalContext == null ? void 0 : (_portalContext$portal2 = portalContext.portalNode) == null ? void 0 : _portalContext$portal2.querySelectorAll('[data-floating-ui-portal]')) != null ? _portalContext$portal : []);\n    function getDismissButtons() {\n      return [startDismissButtonRef.current, endDismissButtonRef.current].filter(Boolean);\n    }\n    let isPointerDown = false; // In Safari, buttons lose focus when pressing them.\n\n    function handlePointerDown() {\n      isPointerDown = true;\n      setTimeout(() => {\n        isPointerDown = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      const movedToUnrelatedNode = !(contains(reference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || [portalContext == null ? void 0 : portalContext.beforeOutsideRef.current, portalContext == null ? void 0 : portalContext.afterOutsideRef.current].filter(Boolean).includes(relatedTarget) || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n        var _node$context, _node$context2;\n        return contains((_node$context = node.context) == null ? void 0 : _node$context.refs.floating.current, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.refs.domReference.current, relatedTarget);\n      }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n        var _node$context3, _node$context4;\n        return ((_node$context3 = node.context) == null ? void 0 : _node$context3.refs.floating.current) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.refs.domReference.current) === relatedTarget;\n      }))); // Focus did not move inside the floating tree, and there are no tabbable\n      // portal guards to handle closing.\n\n      if (relatedTarget && movedToUnrelatedNode && !isPointerDown &&\n      // Fix React 18 Strict Mode returnFocus due to double rendering.\n      relatedTarget !== previouslyFocusedElementRef.current) {\n        preventReturnFocusRef.current = true; // On iOS VoiceOver, dismissing the nested submenu will cause the\n        // first item of the list to receive focus. Delaying it appears to fix\n        // the issue.\n\n        setTimeout(() => onOpenChange(false));\n      }\n    }\n    if (floating && isHTMLElement(reference)) {\n      let cleanup;\n      if (modal) {\n        const insideNodes = [floating, ...portalNodes, ...getDismissButtons()];\n        cleanup = hideOthers(orderRef.current.includes('reference') || typeableCombobox ? insideNodes.concat(reference) : insideNodes);\n      }\n      reference.addEventListener('focusout', handleFocusOutside);\n      reference.addEventListener('pointerdown', handlePointerDown);\n      !modal && floating.addEventListener('focusout', handleFocusOutside);\n      return () => {\n        reference.removeEventListener('focusout', handleFocusOutside);\n        reference.removeEventListener('pointerdown', handlePointerDown);\n        !modal && floating.removeEventListener('focusout', handleFocusOutside);\n        cleanup == null ? void 0 : cleanup();\n      };\n    }\n  }, [modal, initialFocus, nodeId, tree, orderRef, refs, portalContext, typeableCombobox, initialFocusControlled, onOpenChange]);\n  React.useEffect(() => {\n    const floating = refs.floating.current;\n    if (modal && !guards && floating) {\n      const tabIndexValues = [];\n      const options = getTabbableOptions();\n      const allTabbable = tabbable(getDocument(floating).body, options);\n      const floatingTabbable = getTabbableElements(); // Exclude all tabbable elements that are part of the order\n\n      const elements = allTabbable.filter(el => !floatingTabbable.includes(el));\n      elements.forEach((el, i) => {\n        tabIndexValues[i] = el.getAttribute('tabindex');\n        el.setAttribute('tabindex', '-1');\n      });\n      return () => {\n        elements.forEach((el, i) => {\n          const value = tabIndexValues[i];\n          if (value == null) {\n            el.removeAttribute('tabindex');\n          } else {\n            el.setAttribute('tabindex', value);\n          }\n        });\n      };\n    }\n  }, [modal, guards, refs, getTabbableElements]); // Layout effect to ensure that the previouslyFocusedElement is set before\n  // focus is moved inside the floating element via hooks like\n  // useListNavigation.\n\n  index(() => {\n    const floating = refs.floating.current;\n    if (!floating) {\n      return;\n    }\n    const doc = getDocument(floating);\n    let returnFocusValue = returnFocus;\n    let preventReturnFocusScroll = false;\n    const previouslyFocusedElement = activeElement(doc);\n    previouslyFocusedElementRef.current = previouslyFocusedElement;\n    const focusableElements = getTabbableElements(floating);\n    const elToFocus = (typeof initialFocus === 'number' ? focusableElements[initialFocus] : initialFocus.current) || floating; // If the `useListNavigation` hook is active, always ignore `initialFocus`\n    // because it has its own handling of the initial focus.\n\n    !initialFocusControlled && enqueueFocus(elToFocus, {\n      preventScroll: elToFocus === floating\n    }); // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n\n    function onDismiss(payload) {\n      if (payload.type === 'escapeKey' && refs.domReference.current) {\n        previouslyFocusedElementRef.current = refs.domReference.current;\n      }\n      if (payload.type !== 'outsidePress') {\n        return;\n      }\n      const returnFocus = payload.data.returnFocus;\n      if (typeof returnFocus === 'object') {\n        returnFocusValue = true;\n        preventReturnFocusScroll = returnFocus.preventScroll;\n      } else {\n        returnFocusValue = returnFocus;\n      }\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n      if (contains(floating, activeElement(doc)) && refs.domReference.current) {\n        previouslyFocusedElementRef.current = refs.domReference.current;\n      }\n      if (returnFocusValue && isHTMLElement(previouslyFocusedElementRef.current) && !preventReturnFocusRef.current) {\n        enqueueFocus(previouslyFocusedElementRef.current, {\n          preventScroll: preventReturnFocusScroll,\n          // When dismissing nested floating elements, by the time the rAF has\n          // executed, the menus will all have been unmounted. When they try\n          // to get focused, the calls get ignored â€” leaving the root reference\n          // focused as desired.\n          cancelPrevious: false\n        });\n      }\n    };\n  }, [getTabbableElements, initialFocus, returnFocus, refs, events, initialFocusControlled]); // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n\n  index(() => {\n    if (!portalContext) return;\n    portalContext.setFocusManagerState({\n      ...context,\n      modal // Not concerned about the <RT> generic type.\n    });\n\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [portalContext, modal, context]);\n  index(() => {\n    if (getTabbableContent().length === 0 && !initialFocusControlled) {\n      setTabbableContentLength(0);\n    }\n  }, [getTabbableContent, refs, initialFocusControlled]);\n  const shouldRenderGuards = guards && (insidePortal || modal) && !typeableCombobox;\n  function renderDismissButton(location) {\n    return visuallyHiddenDismiss && modal ? /*#__PURE__*/React.createElement(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: () => onOpenChange(false)\n    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss') : null;\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n    onFocus: event => {\n      if (modal) {\n        const els = getTabbableElements();\n        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = false;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const nextTabbable = getNextTabbable() || domReference;\n          nextTabbable == null ? void 0 : nextTabbable.focus();\n        } else {\n          var _portalContext$before;\n          (_portalContext$before = portalContext.beforeOutsideRef.current) == null ? void 0 : _portalContext$before.focus();\n        }\n      }\n    }\n  }), typeableCombobox ? null : renderDismissButton('start'), /*#__PURE__*/React.cloneElement(children, tabbableContentLength === 0 || order.includes('floating') ? {\n    tabIndex: 0\n  } : {}), renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n    onFocus: event => {\n      if (modal) {\n        enqueueFocus(getTabbableElements()[0]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = true;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const prevTabbable = getPreviousTabbable() || domReference;\n          prevTabbable == null ? void 0 : prevTabbable.focus();\n        } else {\n          var _portalContext$afterO;\n          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null ? void 0 : _portalContext$afterO.focus();\n        }\n      }\n    }\n  }));\n}\n\n// On some Linux machines with Chromium, mouse inputs return a `pointerType` of\n// \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\nconst mouseLikePointerTypes = ['mouse', 'pen', '', undefined];\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !mouseLikePointerTypes.includes(pointerType)) {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return value == null ? void 0 : value[prop];\n}\n\n/**\n * Adds hover event listeners that change the open state, like CSS :hover.\n * @see https://floating-ui.com/docs/useHover\n */\nconst useHover = function (context, _temp) {\n  let {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = _temp === void 0 ? {} : _temp;\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    refs,\n    _\n  } = context;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = useLatestRef(handleClose);\n  const delayRef = useLatestRef(delay);\n  const pointerTypeRef = React.useRef();\n  const timeoutRef = React.useRef();\n  const handlerRef = React.useRef();\n  const restTimeoutRef = React.useRef();\n  const blockMouseMoveRef = React.useRef(true);\n  const performedPointerEventsMutationRef = React.useRef(false);\n  const isHoverOpen = React.useCallback(() => {\n    var _dataRef$current$open;\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  }, [dataRef]); // When dismissing before opening, clear the delay timeouts to cancel it\n  // from showing.\n\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onDismiss() {\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      blockMouseMoveRef.current = true;\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [enabled, events, refs]);\n  React.useEffect(() => {\n    if (!enabled || !handleCloseRef.current || !open) {\n      return;\n    }\n    function onLeave() {\n      if (isHoverOpen()) {\n        onOpenChange(false);\n      }\n    }\n    const html = getDocument(refs.floating.current).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [refs, open, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);\n  const closeWithDelay = React.useCallback(function (runElseBranch) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => onOpenChange(false), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChange(false);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = React.useCallback(() => {\n    if (handlerRef.current) {\n      getDocument(refs.floating.current).removeEventListener('mousemove', handlerRef.current);\n      handlerRef.current = undefined;\n    }\n  }, [refs]);\n  const clearPointerEvents = React.useCallback(() => {\n    getDocument(refs.floating.current).body.style.pointerEvents = '';\n    performedPointerEventsMutationRef.current = false;\n  }, [refs]); // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function isClickLikeOpenEvent() {\n      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n    }\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n      if (mouseOnly && !mouseLikePointerTypes.includes(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {\n        return;\n      }\n      dataRef.current.openEvent = event;\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n      if (openDelay) {\n        timeoutRef.current = setTimeout(() => {\n          onOpenChange(true);\n        }, openDelay);\n      } else {\n        onOpenChange(true);\n      }\n    }\n    function onMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      const doc = getDocument(refs.floating.current);\n      clearTimeout(restTimeoutRef.current);\n      if (handleCloseRef.current) {\n        clearTimeout(timeoutRef.current);\n        handlerRef.current && doc.removeEventListener('mousemove', handlerRef.current);\n        handlerRef.current = handleCloseRef.current({\n          ...context,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            closeWithDelay();\n          }\n        });\n        doc.addEventListener('mousemove', handlerRef.current);\n        return;\n      }\n      closeWithDelay();\n    } // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      handleCloseRef.current == null ? void 0 : handleCloseRef.current({\n        ...context,\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        leave: true,\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          closeWithDelay();\n        }\n      })(event);\n    }\n    const floating = refs.floating.current;\n    const reference = refs.domReference.current;\n    if (isElement(reference)) {\n      open && reference.addEventListener('mouseleave', onScrollMouseLeave);\n      floating == null ? void 0 : floating.addEventListener('mouseleave', onScrollMouseLeave);\n      move && reference.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      reference.addEventListener('mouseenter', onMouseEnter);\n      reference.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        open && reference.removeEventListener('mouseleave', onScrollMouseLeave);\n        floating == null ? void 0 : floating.removeEventListener('mouseleave', onScrollMouseLeave);\n        move && reference.removeEventListener('mousemove', onMouseEnter);\n        reference.removeEventListener('mouseenter', onMouseEnter);\n        reference.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [\n  // Ensure the effect is re-run when the reference changes.\n  // https://github.com/floating-ui/floating-ui/issues/1833\n  _.domReference, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, refs, delayRef, handleCloseRef, dataRef]); // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && handleCloseRef.current && handleCloseRef.current.__options.blockPointerEvents && isHoverOpen()) {\n      getDocument(refs.floating.current).body.style.pointerEvents = 'none';\n      performedPointerEventsMutationRef.current = true;\n      const reference = refs.domReference.current;\n      const floating = refs.floating.current;\n      if (isElement(reference) && floating) {\n        var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.refs.floating.current;\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n        reference.style.pointerEvents = 'auto';\n        floating.style.pointerEvents = 'auto';\n        return () => {\n          reference.style.pointerEvents = '';\n          floating.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, refs, tree, handleCloseRef, dataRef, isHoverOpen]);\n  index(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      cleanupMouseMoveHandler();\n      if (performedPointerEventsMutationRef.current) {\n        clearPointerEvents();\n      }\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n  React.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      if (performedPointerEventsMutationRef.current) {\n        clearPointerEvents();\n      }\n    };\n  }, [enabled, cleanupMouseMoveHandler, clearPointerEvents]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerRef,\n        onPointerEnter: setPointerRef,\n        onMouseMove() {\n          if (open || restMs === 0) {\n            return;\n          }\n          clearTimeout(restTimeoutRef.current);\n          restTimeoutRef.current = setTimeout(() => {\n            if (!blockMouseMoveRef.current) {\n              onOpenChange(true);\n            }\n          }, restMs);\n        }\n      },\n      floating: {\n        onMouseEnter() {\n          clearTimeout(timeoutRef.current);\n        },\n        onMouseLeave() {\n          closeWithDelay(false);\n        }\n      }\n    };\n  }, [enabled, restMs, open, onOpenChange, closeWithDelay]);\n};\nconst FloatingDelayGroupContext = /*#__PURE__*/React.createContext({\n  delay: 1000,\n  initialDelay: 1000,\n  currentId: null,\n  setCurrentId: () => {},\n  setState: () => {}\n});\nconst useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\n\nconst FloatingDelayGroup = _ref => {\n  let {\n    children,\n    delay\n  } = _ref;\n  const [state, setState] = React.useState({\n    delay,\n    initialDelay: delay,\n    currentId: null\n  });\n  const setCurrentId = React.useCallback(currentId => {\n    setState(state => ({\n      ...state,\n      currentId\n    }));\n  }, []);\n  return /*#__PURE__*/React.createElement(FloatingDelayGroupContext.Provider, {\n    value: React.useMemo(() => ({\n      ...state,\n      setState,\n      setCurrentId\n    }), [state, setState, setCurrentId])\n  }, children);\n};\nconst useDelayGroup = (_ref2, _ref3) => {\n  let {\n    open,\n    onOpenChange\n  } = _ref2;\n  let {\n    id\n  } = _ref3;\n  const {\n    currentId,\n    initialDelay,\n    setState\n  } = useDelayGroupContext();\n  React.useEffect(() => {\n    if (currentId) {\n      setState(state => ({\n        ...state,\n        delay: {\n          open: 1,\n          close: getDelay(initialDelay, 'close')\n        }\n      }));\n      if (currentId !== id) {\n        onOpenChange(false);\n      }\n    }\n  }, [id, onOpenChange, setState, currentId, initialDelay]);\n  React.useEffect(() => {\n    if (!open && currentId === id) {\n      onOpenChange(false);\n      setState(state => ({\n        ...state,\n        delay: initialDelay,\n        currentId: null\n      }));\n    }\n  }, [open, setState, currentId, id, onOpenChange, initialDelay]);\n};\nfunction getArgsWithCustomFloatingHeight(args, height) {\n  return {\n    ...args,\n    rects: {\n      ...args.rects,\n      floating: {\n        ...args.rects.floating,\n        height\n      }\n    }\n  };\n}\nconst inner = options => ({\n  name: 'inner',\n  options,\n  async fn(middlewareArguments) {\n    var _scrollRef$current;\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = options;\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = middlewareArguments;\n    const item = listRef.current[index];\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!middlewareArguments.placement.startsWith('bottom')) {\n        console.warn(['Floating UI: `placement` side must be \"bottom\" when using the', '`inner` middleware.'].join(' '));\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = {\n      ...middlewareArguments,\n      ...(await offset(-item.offsetTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(middlewareArguments))\n    };\n    const el = (_scrollRef$current = scrollRef == null ? void 0 : scrollRef.current) != null ? _scrollRef$current : floating;\n    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n    const refOverflow = await detectOverflow(nextArgs, {\n      ...detectOverflowOptions,\n      elementContext: 'reference'\n    });\n    const diffY = Math.max(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n    el.style.maxHeight = maxHeight + \"px\";\n    el.scrollTop = diffY; // There is not enough space, fallback to standard anchored positioning\n\n    if (onFallbackChange) {\n      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n        flushSync(() => onFallbackChange(true));\n      } else {\n        flushSync(() => onFallbackChange(false));\n      }\n    }\n    if (overflowRef) {\n      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({\n        ...nextArgs,\n        y: nextY\n      }, el.offsetHeight), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\nconst useInnerOffset = (_ref, _ref2) => {\n  let {\n    open,\n    refs\n  } = _ref;\n  let {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = _ref2;\n  const onChange = useEvent(unstable_onChange);\n  const controlledScrollingRef = React.useRef(false);\n  const prevScrollTopRef = React.useRef(null);\n  const initialOverflowRef = React.useRef(null);\n  React.useEffect(() => {\n    var _scrollRef$current2;\n    if (!enabled) {\n      return;\n    }\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        flushSync(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test(getUserAgent())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n    const el = (_scrollRef$current2 = scrollRef == null ? void 0 : scrollRef.current) != null ? _scrollRef$current2 : refs.floating.current;\n    if (open && el) {\n      el.addEventListener('wheel', onWheel); // Wait for the position to be ready.\n\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = {\n            ...overflowRef.current\n          };\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, refs, overflowRef, scrollRef, onChange]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      floating: {\n        onKeyDown() {\n          controlledScrollingRef.current = true;\n        },\n        onWheel() {\n          controlledScrollingRef.current = false;\n        },\n        onPointerMove() {\n          controlledScrollingRef.current = false;\n        },\n        onScroll() {\n          const el = (scrollRef == null ? void 0 : scrollRef.current) || refs.floating.current;\n          if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n            return;\n          }\n          if (prevScrollTopRef.current !== null) {\n            const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n              flushSync(() => onChange(d => d + scrollDiff));\n            }\n          } // [Firefox] Wait for the height change to have been applied.\n\n          requestAnimationFrame(() => {\n            prevScrollTopRef.current = el.scrollTop;\n          });\n        }\n      }\n    };\n  }, [enabled, overflowRef, refs, scrollRef, onChange]);\n};\n\n/**\n * Adds relevant screen reader props for a given element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nconst useRole = function (_ref, _temp) {\n  let {\n    open\n  } = _ref;\n  let {\n    enabled = true,\n    role = 'dialog'\n  } = _temp === void 0 ? {} : _temp;\n  const rootId = useId();\n  const referenceId = useId();\n  return React.useMemo(() => {\n    const floatingProps = {\n      id: rootId,\n      role\n    };\n    if (!enabled) {\n      return {};\n    }\n    if (role === 'tooltip') {\n      return {\n        reference: {\n          'aria-describedby': open ? rootId : undefined\n        },\n        floating: floatingProps\n      };\n    }\n    return {\n      reference: {\n        'aria-expanded': open ? 'true' : 'false',\n        'aria-haspopup': role === 'alertdialog' ? 'dialog' : role,\n        'aria-controls': open ? rootId : undefined,\n        ...(role === 'listbox' && {\n          role: 'combobox'\n        }),\n        ...(role === 'menu' && {\n          id: referenceId\n        })\n      },\n      floating: {\n        ...floatingProps,\n        ...(role === 'menu' && {\n          'aria-labelledby': referenceId\n        })\n      }\n    };\n  }, [enabled, role, open, rootId, referenceId]);\n};\nfunction isButtonTarget(event) {\n  return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';\n}\nfunction isSpaceIgnored(element) {\n  return isTypeableElement(element);\n}\n\n/**\n * Adds click event listeners that change the open state.\n * @see https://floating-ui.com/docs/useClick\n */\nconst useClick = function (_ref, _temp) {\n  let {\n    open,\n    onOpenChange,\n    dataRef,\n    refs\n  } = _ref;\n  let {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true\n  } = _temp === void 0 ? {} : _temp;\n  const pointerTypeRef = React.useRef();\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(event) {\n          pointerTypeRef.current = event.pointerType;\n        },\n        onMouseDown(event) {\n          // Ignore all buttons except for the \"main\" button.\n          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n          if (event.button !== 0) {\n            return;\n          }\n          if (pointerTypeRef.current === 'mouse' && ignoreMouse) {\n            return;\n          }\n          if (eventOption === 'click') {\n            return;\n          }\n          if (open) {\n            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n              onOpenChange(false);\n            }\n          } else {\n            // Prevent stealing focus from the floating element\n            event.preventDefault();\n            onOpenChange(true);\n          }\n          dataRef.current.openEvent = event.nativeEvent;\n        },\n        onClick(event) {\n          if (eventOption === 'mousedown' && pointerTypeRef.current) {\n            pointerTypeRef.current = undefined;\n            return;\n          }\n          if (pointerTypeRef.current === 'mouse' && ignoreMouse) {\n            return;\n          }\n          if (open) {\n            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n              onOpenChange(false);\n            }\n          } else {\n            onOpenChange(true);\n          }\n          dataRef.current.openEvent = event.nativeEvent;\n        },\n        onKeyDown(event) {\n          pointerTypeRef.current = undefined;\n          if (!keyboardHandlers) {\n            return;\n          }\n          if (isButtonTarget(event)) {\n            return;\n          }\n          if (event.key === ' ' && !isSpaceIgnored(refs.domReference.current)) {\n            // Prevent scrolling\n            event.preventDefault();\n          }\n          if (event.key === 'Enter') {\n            if (open) {\n              if (toggle) {\n                onOpenChange(false);\n              }\n            } else {\n              onOpenChange(true);\n            }\n          }\n        },\n        onKeyUp(event) {\n          if (!keyboardHandlers) {\n            return;\n          }\n          if (isButtonTarget(event) || isSpaceIgnored(refs.domReference.current)) {\n            return;\n          }\n          if (event.key === ' ') {\n            if (open) {\n              if (toggle) {\n                onOpenChange(false);\n              }\n            } else {\n              onOpenChange(true);\n            }\n          }\n        }\n      }\n    };\n  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, refs, toggle, open, onOpenChange]);\n};\n\n/**\n * Check whether the event.target is within the provided node. Uses event.composedPath if available for custom element support.\n *\n * @param event The event whose target/composedPath to check\n * @param node The node to check against\n * @returns Whether the event.target/composedPath is within the node.\n */\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  } // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\n\n/**\n * Adds listeners that dismiss (close) the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nconst useDismiss = function (_ref, _temp) {\n  let {\n    open,\n    onOpenChange,\n    refs,\n    events,\n    nodeId\n  } = _ref;\n  let {\n    enabled = true,\n    escapeKey = true,\n    outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles = true\n  } = _temp === void 0 ? {} : _temp;\n  const tree = useFloatingTree();\n  const nested = useFloatingParentNodeId() != null;\n  const outsidePressRef = useLatestRef(outsidePress);\n  const insideReactTreeRef = React.useRef(false);\n  React.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n    const outsidePress = outsidePressRef.current;\n    function onKeyDown(event) {\n      if (event.key === 'Escape') {\n        if (!bubbles && tree && getChildren(tree.nodesRef.current, nodeId).length > 0) {\n          return;\n        }\n        events.emit('dismiss', {\n          type: 'escapeKey',\n          data: {\n            returnFocus: {\n              preventScroll: false\n            }\n          }\n        });\n        onOpenChange(false);\n      }\n    }\n    function onOutsidePress(event) {\n      // Given developers can stop the propagation of the synthetic event,\n      // we can only be confident with a positive value.\n      const insideReactTree = insideReactTreeRef.current;\n      insideReactTreeRef.current = false;\n      if (insideReactTree) {\n        return;\n      }\n      if (typeof outsidePress === 'function' && !outsidePress(event)) {\n        return;\n      }\n      const target = getTarget(event); // Check if the click occurred on the scrollbar\n\n      if (isElement(target) && refs.floating.current) {\n        var _refs$floating$curren;\n        const win = (_refs$floating$curren = refs.floating.current.ownerDocument.defaultView) != null ? _refs$floating$curren : window;\n        const canScrollX = target.scrollWidth > target.clientWidth;\n        const canScrollY = target.scrollHeight > target.clientHeight;\n        let xCond = canScrollY && event.offsetX > target.clientWidth; // In some browsers it is possible to change the <body> (or window)\n        // scrollbar to the left side, but is very rare and is difficult to\n        // check for. Plus, for modal dialogs with backdrops, it is more\n        // important that the backdrop is checked but not so much the window.\n\n        if (canScrollY) {\n          const isRTL = win.getComputedStyle(target).direction === 'rtl';\n          if (isRTL) {\n            xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n          }\n        }\n        if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n          return;\n        }\n      }\n      const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context;\n        return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.refs.floating.current);\n      });\n      if (isEventTargetWithin(event, refs.floating.current) || isEventTargetWithin(event, refs.domReference.current) || targetIsInsideChildren) {\n        return;\n      }\n      if (!bubbles && tree && getChildren(tree.nodesRef.current, nodeId).length > 0) {\n        return;\n      }\n      events.emit('dismiss', {\n        type: 'outsidePress',\n        data: {\n          returnFocus: nested ? {\n            preventScroll: true\n          } : isVirtualClick(event) || isVirtualPointerEvent(event)\n        }\n      });\n      onOpenChange(false);\n    }\n    function onScroll() {\n      onOpenChange(false);\n    }\n    const doc = getDocument(refs.floating.current);\n    escapeKey && doc.addEventListener('keydown', onKeyDown);\n    outsidePress && doc.addEventListener(outsidePressEvent, onOutsidePress);\n    let ancestors = [];\n    if (ancestorScroll) {\n      if (isElement(refs.domReference.current)) {\n        ancestors = getOverflowAncestors(refs.domReference.current);\n      }\n      if (isElement(refs.floating.current)) {\n        ancestors = ancestors.concat(getOverflowAncestors(refs.floating.current));\n      }\n      if (!isElement(refs.reference.current) && refs.reference.current &&\n      // @ts-expect-error is VirtualElement\n      refs.reference.current.contextElement) {\n        ancestors = ancestors.concat(\n        // @ts-expect-error is VirtualElement\n        getOverflowAncestors(refs.reference.current.contextElement));\n      }\n    } // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      escapeKey && doc.removeEventListener('keydown', onKeyDown);\n      outsidePress && doc.removeEventListener(outsidePressEvent, onOutsidePress);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n    };\n  }, [escapeKey, outsidePressRef, outsidePressEvent, events, tree, nodeId, open, onOpenChange, ancestorScroll, enabled, bubbles, refs, nested]);\n  React.useEffect(() => {\n    insideReactTreeRef.current = false;\n  }, [outsidePress, outsidePressEvent]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        [bubbleHandlerKeys[referencePressEvent]]: () => {\n          if (referencePress) {\n            events.emit('dismiss', {\n              type: 'referencePress',\n              data: {\n                returnFocus: false\n              }\n            });\n            onOpenChange(false);\n          }\n        }\n      },\n      floating: {\n        [captureHandlerKeys[outsidePressEvent]]: () => {\n          insideReactTreeRef.current = true;\n        }\n      }\n    };\n  }, [enabled, events, referencePress, outsidePressEvent, referencePressEvent, onOpenChange]);\n};\n\n/**\n * Adds focus event listeners that change the open state, like CSS :focus.\n * @see https://floating-ui.com/docs/useFocus\n */\nconst useFocus = function (_ref, _temp) {\n  let {\n    open,\n    onOpenChange,\n    dataRef,\n    refs,\n    events\n  } = _ref;\n  let {\n    enabled = true,\n    keyboardOnly = true\n  } = _temp === void 0 ? {} : _temp;\n  const pointerTypeRef = React.useRef('');\n  const blockFocusRef = React.useRef(false);\n  const timeoutRef = React.useRef();\n  React.useEffect(() => {\n    var _doc$defaultView;\n    if (!enabled) {\n      return;\n    }\n    const doc = getDocument(refs.floating.current);\n    const win = (_doc$defaultView = doc.defaultView) != null ? _doc$defaultView : window; // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n\n    function onBlur() {\n      if (!open && isHTMLElement(refs.domReference.current) && refs.domReference.current === activeElement(getDocument(refs.domReference.current))) {\n        blockFocusRef.current = true;\n      }\n    }\n    win.addEventListener('blur', onBlur);\n    return () => {\n      win.removeEventListener('blur', onBlur);\n    };\n  }, [refs, open, enabled]);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onDismiss(payload) {\n      if (payload.type === 'referencePress' || payload.type === 'escapeKey') {\n        blockFocusRef.current = true;\n      }\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [events, enabled]);\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(timeoutRef.current);\n    };\n  }, []);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(_ref2) {\n          let {\n            pointerType\n          } = _ref2;\n          pointerTypeRef.current = pointerType;\n          blockFocusRef.current = !!(pointerType && keyboardOnly);\n        },\n        onMouseLeave() {\n          blockFocusRef.current = false;\n        },\n        onFocus(event) {\n          var _dataRef$current$open;\n          if (blockFocusRef.current) {\n            return;\n          } // Dismiss with click should ignore the subsequent `focus` trigger,\n          // but only if the click originated inside the reference element.\n\n          if (event.type === 'focus' && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === 'mousedown' && dataRef.current.openEvent && isEventTargetWithin(dataRef.current.openEvent, refs.domReference.current)) {\n            return;\n          }\n          dataRef.current.openEvent = event.nativeEvent;\n          onOpenChange(true);\n        },\n        onBlur(event) {\n          blockFocusRef.current = false;\n          const relatedTarget = event.relatedTarget; // Hit the non-modal focus management portal guard. Focus will be\n          // moved into the floating element immediately after.\n\n          const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute('data-floating-ui-focus-guard'); // Wait for the window blur listener to fire.\n\n          timeoutRef.current = setTimeout(() => {\n            // When focusing the reference element (e.g. regular click), then\n            // clicking into the floating element, prevent it from hiding.\n            // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n            if (contains(refs.floating.current, relatedTarget) || contains(refs.domReference.current, relatedTarget) || movedToFocusGuard) {\n              return;\n            }\n            onOpenChange(false);\n          });\n        }\n      }\n    };\n  }, [enabled, keyboardOnly, refs, dataRef, onOpenChange]);\n};\nlet isPreventScrollSupported = false;\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nfunction isDifferentRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  let index = startingIndex;\n  do {\n    var _list$index, _list$index2;\n    index = index + (decrement ? -amount : amount);\n  } while (index >= 0 && index <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index) : list[index] == null || ((_list$index = list[index]) == null ? void 0 : _list$index.hasAttribute('disabled')) || ((_list$index2 = list[index]) == null ? void 0 : _list$index2.getAttribute('aria-disabled')) === 'true'));\n  return index;\n}\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key == ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\n\n/**\n * Adds focus-managed indexed navigation via arrow keys to a list of items\n * within the floating element.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nconst useListNavigation = function (_ref, _temp2) {\n  let {\n    open,\n    onOpenChange,\n    refs\n  } = _ref;\n  let {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    cols = 1\n  } = _temp2 === void 0 ? {\n    listRef: {\n      current: []\n    },\n    activeIndex: null,\n    onNavigate: () => {}\n  } : _temp2;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (allowEscape) {\n      if (!loop) {\n        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));\n      }\n      if (!virtual) {\n        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either \"horizontal\" or \"both\".'].join(' '));\n    }\n  }\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const onNavigate = useEvent(unstable_onNavigate);\n  const focusItemOnOpenRef = React.useRef(focusItemOnOpen);\n  const indexRef = React.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = React.useRef(null);\n  const blockPointerLeaveRef = React.useRef(false);\n  const previousOnNavigateRef = React.useRef(onNavigate);\n  const previousOpenRef = React.useRef(open);\n  const forceSyncFocus = React.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const [activeId, setActiveId] = React.useState();\n  const focusItem = React.useCallback((listRef, indexRef) => {\n    if (virtual) {\n      var _listRef$current$inde;\n      setActiveId((_listRef$current$inde = listRef.current[indexRef.current]) == null ? void 0 : _listRef$current$inde.id);\n    } else {\n      const item = listRef.current[indexRef.current];\n      enqueueFocus(item, {\n        preventScroll: true,\n        // Mac Safari does not move the virtual cursor unless the focus call\n        // is sync. However, for the very first focus call, we need to wait\n        // for the position to be ready in order to prevent unwanted\n        // scrolling. This means the virtual cursor will not move to the first\n        // item when first opening the floating element, but will on\n        // subsequent calls. `preventScroll` is supported in modern Safari,\n        // so we can use that instead.\n        // iOS Safari must be async or the first item will not be focused.\n        sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false\n      });\n    }\n  }, [virtual]);\n  index(() => {\n    document.createElement('div').focus({\n      get preventScroll() {\n        isPreventScrollSupported = true;\n        return false;\n      }\n    });\n  }, []); // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        onNavigate(selectedIndex);\n      }\n    } else if (previousOpenRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function\n      indexRef.current = -1;\n      previousOnNavigateRef.current(null);\n    }\n  }, [enabled, open, selectedIndex, onNavigate]); // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open) {\n      if (activeIndex == null) {\n        forceSyncFocus.current = false;\n        if (selectedIndex != null) {\n          return;\n        } // Reset while the floating element was open (e.g. the list changed).\n\n        if (previousOpenRef.current) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        } // Initial sync\n\n        if (!previousOpenRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n          onNavigate(indexRef.current);\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef);\n      }\n    }\n  }, [enabled, open, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]); // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (previousOpenRef.current && !open) {\n      var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n      const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.refs.floating.current;\n      if (parentFloating && !contains(parentFloating, activeElement(getDocument(parentFloating)))) {\n        parentFloating.focus({\n          preventScroll: true\n        });\n      }\n    }\n  }, [enabled, open, tree, parentId]);\n  index(() => {\n    keyRef.current = null;\n    previousOnNavigateRef.current = onNavigate;\n    previousOpenRef.current = open;\n  });\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    const disabledIndices = disabledIndicesRef.current;\n    function onKeyDown(event) {\n      blockPointerLeaveRef.current = true;\n      forceSyncFocus.current = true; // If the floating element is animating out, ignore navigation. Otherwise,\n      // the `activeIndex` gets set to 0 despite not being open so the next time\n      // the user ArrowDowns, the first item won't be focused.\n\n      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n        return;\n      }\n      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n        stopEvent(event);\n        onOpenChange(false);\n        if (isHTMLElement(refs.domReference.current)) {\n          refs.domReference.current.focus();\n        }\n        return;\n      }\n      const currentIndex = indexRef.current;\n      const minIndex = getMinIndex(listRef, disabledIndices);\n      const maxIndex = getMaxIndex(listRef, disabledIndices);\n      if (event.key === 'Home') {\n        indexRef.current = minIndex;\n        onNavigate(indexRef.current);\n      }\n      if (event.key === 'End') {\n        indexRef.current = maxIndex;\n        onNavigate(indexRef.current);\n      } // Grid navigation\n\n      if (cols > 1) {\n        const prevIndex = indexRef.current;\n        if (event.key === ARROW_UP) {\n          stopEvent(event);\n          if (prevIndex === -1) {\n            indexRef.current = maxIndex;\n          } else {\n            indexRef.current = findNonDisabledIndex(listRef, {\n              startingIndex: prevIndex,\n              amount: cols,\n              decrement: true,\n              disabledIndices\n            });\n            if (loop && (prevIndex - cols < minIndex || indexRef.current < 0)) {\n              const col = prevIndex % cols;\n              const maxCol = maxIndex % cols;\n              const offset = maxIndex - (maxCol - col);\n              if (maxCol === col) {\n                indexRef.current = maxIndex;\n              } else {\n                indexRef.current = maxCol > col ? offset : offset - cols;\n              }\n            }\n          }\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            indexRef.current = prevIndex;\n          }\n          onNavigate(indexRef.current);\n        }\n        if (event.key === ARROW_DOWN) {\n          stopEvent(event);\n          if (prevIndex === -1) {\n            indexRef.current = minIndex;\n          } else {\n            indexRef.current = findNonDisabledIndex(listRef, {\n              startingIndex: prevIndex,\n              amount: cols,\n              disabledIndices\n            });\n            if (loop && prevIndex + cols > maxIndex) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex % cols - cols,\n                amount: cols,\n                disabledIndices\n              });\n            }\n          }\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            indexRef.current = prevIndex;\n          }\n          onNavigate(indexRef.current);\n        } // Remains on the same row/column\n\n        if (orientation === 'both') {\n          const prevRow = Math.floor(prevIndex / cols);\n          if (event.key === ARROW_RIGHT) {\n            stopEvent(event);\n            if (prevIndex % cols !== cols - 1) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                disabledIndices\n              });\n              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex - prevIndex % cols - 1,\n                  disabledIndices\n                });\n              }\n            } else if (loop) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex - prevIndex % cols - 1,\n                disabledIndices\n              });\n            }\n            if (isDifferentRow(indexRef.current, cols, prevRow)) {\n              indexRef.current = prevIndex;\n            }\n          }\n          if (event.key === ARROW_LEFT) {\n            stopEvent(event);\n            if (prevIndex % cols !== 0) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                disabledIndices,\n                decrement: true\n              });\n              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex + (cols - prevIndex % cols),\n                  decrement: true,\n                  disabledIndices\n                });\n              }\n            } else if (loop) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex + (cols - prevIndex % cols),\n                decrement: true,\n                disabledIndices\n              });\n            }\n            if (isDifferentRow(indexRef.current, cols, prevRow)) {\n              indexRef.current = prevIndex;\n            }\n          }\n          const lastRow = Math.floor(maxIndex / cols) === prevRow;\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            if (loop && lastRow) {\n              indexRef.current = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex - prevIndex % cols - 1,\n                disabledIndices\n              });\n            } else {\n              indexRef.current = prevIndex;\n            }\n          }\n          onNavigate(indexRef.current);\n          return;\n        }\n      }\n      if (isMainOrientationKey(event.key, orientation)) {\n        stopEvent(event); // Reset the index if no item is focused.\n\n        if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n          onNavigate(indexRef.current);\n          return;\n        }\n        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n          if (loop) {\n            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            }));\n          }\n        } else {\n          if (loop) {\n            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            }));\n          }\n        }\n        if (isIndexOutOfBounds(listRef, indexRef.current)) {\n          onNavigate(null);\n        } else {\n          onNavigate(indexRef.current);\n        }\n      }\n    }\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    return {\n      reference: {\n        ...(virtual && open && activeIndex != null && {\n          'aria-activedescendant': activeId\n        }),\n        onKeyDown(event) {\n          blockPointerLeaveRef.current = true;\n          const isArrowKey = event.key.indexOf('Arrow') === 0;\n          if (virtual && open) {\n            return onKeyDown(event);\n          } // If a floating element should not open on arrow key down, avoid\n          // setting `activeIndex` while it's closed.\n\n          if (!open && !openOnArrowKeyDown && isArrowKey) {\n            return;\n          }\n          const isNavigationKey = isArrowKey || event.key === 'Enter' || event.key === ' ' || event.key === '';\n          if (isNavigationKey) {\n            keyRef.current = event.key;\n          }\n          if (nested) {\n            if (isCrossOrientationOpenKey(event.key, orientation, rtl)) {\n              stopEvent(event);\n              if (open) {\n                indexRef.current = getMinIndex(listRef, disabledIndices);\n                onNavigate(indexRef.current);\n              } else {\n                onOpenChange(true);\n              }\n            }\n            return;\n          }\n          if (isMainOrientationKey(event.key, orientation)) {\n            if (selectedIndex != null) {\n              indexRef.current = selectedIndex;\n            }\n            stopEvent(event);\n            if (!open && openOnArrowKeyDown) {\n              onOpenChange(true);\n            } else {\n              onKeyDown(event);\n            }\n            if (open) {\n              onNavigate(indexRef.current);\n            }\n          }\n        },\n        onFocus() {\n          if (open) {\n            onNavigate(null);\n          }\n        },\n        onPointerDown: checkVirtualPointer,\n        onMouseDown: checkVirtualMouse,\n        onClick: checkVirtualMouse\n      },\n      floating: {\n        'aria-orientation': orientation === 'both' ? undefined : orientation,\n        ...(virtual && activeIndex != null && {\n          'aria-activedescendant': activeId\n        }),\n        onKeyDown,\n        onPointerMove() {\n          blockPointerLeaveRef.current = false;\n        }\n      },\n      item: {\n        onFocus(_ref2) {\n          let {\n            currentTarget\n          } = _ref2;\n          const index = listRef.current.indexOf(currentTarget);\n          if (index !== -1 && activeIndex !== index) {\n            onNavigate(index);\n          }\n        },\n        onClick: _ref3 => {\n          let {\n            currentTarget\n          } = _ref3;\n          return currentTarget.focus({\n            preventScroll: true\n          });\n        },\n        // Safari\n        ...(focusItemOnHover && {\n          onMouseMove(_ref4) {\n            let {\n              currentTarget\n            } = _ref4;\n            const target = currentTarget;\n            if (target) {\n              const index = listRef.current.indexOf(target);\n              if (index !== -1 && activeIndex !== index) {\n                onNavigate(index);\n              }\n            }\n          },\n          onPointerLeave() {\n            if (!blockPointerLeaveRef.current) {\n              indexRef.current = -1;\n              focusItem(listRef, indexRef); // Virtual cursor with VoiceOver on iOS needs this to be flushed\n              // synchronously or there is a glitch that prevents nested\n              // submenus from being accessible.\n\n              flushSync(() => onNavigate(null));\n              if (!virtual) {\n                var _refs$floating$curren;\n\n                // This also needs to be sync to prevent fast mouse movements\n                // from leaving behind a stale active item when landing on a\n                // disabled button item.\n                (_refs$floating$curren = refs.floating.current) == null ? void 0 : _refs$floating$curren.focus({\n                  preventScroll: true\n                });\n              }\n            }\n          }\n        })\n      }\n    };\n  }, [activeId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, activeIndex, nested, selectedIndex, openOnArrowKeyDown, focusItemOnHover, allowEscape, cols, loop, refs, focusItemOnOpen, focusItem, onNavigate, onOpenChange]);\n};\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nconst useTypeahead = function (_ref, _temp) {\n  var _ref2;\n  let {\n    open,\n    dataRef\n  } = _ref;\n  let {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch = () => {},\n    enabled = true,\n    findMatch = null,\n    resetMs = 1000,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = _temp === void 0 ? {\n    listRef: {\n      current: []\n    },\n    activeIndex: null\n  } : _temp;\n  const timeoutIdRef = React.useRef();\n  const stringRef = React.useRef('');\n  const prevIndexRef = React.useRef((_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1);\n  const matchIndexRef = React.useRef(null);\n  const onMatch = useEvent(unstable_onMatch);\n  const findMatchRef = useLatestRef(findMatch);\n  const ignoreKeysRef = useLatestRef(ignoreKeys);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation\n    if (open && stringRef.current === '') {\n      var _ref3;\n      prevIndexRef.current = (_ref3 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref3 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function onKeyDown(event) {\n      // Correctly scope nested non-portalled floating elements. Since the nested\n      // floating element is inside of the another, we find the closest role\n      // that indicates the floating element scope.\n      const target = getTarget(event.nativeEvent);\n      if (isElement(target) && (activeElement(getDocument(target)) !== event.currentTarget ? target.closest('[role=\"dialog\"],[role=\"menu\"],[role=\"listbox\"],[role=\"tree\"],[role=\"grid\"]') !== event.currentTarget : false)) {\n        return;\n      }\n      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n        dataRef.current.typing = true;\n        if (event.key === ' ') {\n          stopEvent(event);\n        }\n      }\n      const listContent = listRef.current;\n      if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n      // Character key\n      event.key.length !== 1 ||\n      // Modifier key\n      event.ctrlKey || event.metaKey || event.altKey) {\n        return;\n      } // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n      // allow it in this case, too.\n\n      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n        var _text$, _text$2;\n        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n      }); // Allows the user to cycle through items that start with the same letter\n      // in rapid succession\n\n      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n      }\n      stringRef.current += event.key;\n      clearTimeout(timeoutIdRef.current);\n      timeoutIdRef.current = setTimeout(() => {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n        dataRef.current.typing = false;\n      }, resetMs);\n      const prevIndex = prevIndexRef.current;\n      const orderedList = [...listContent.slice((prevIndex != null ? prevIndex : 0) + 1), ...listContent.slice(0, (prevIndex != null ? prevIndex : 0) + 1)];\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, stringRef.current) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(stringRef.current.toLocaleLowerCase())) === 0);\n      const index = str ? listContent.indexOf(str) : -1;\n      if (index !== -1) {\n        onMatch(index);\n        matchIndexRef.current = index;\n      }\n    }\n    return {\n      reference: {\n        onKeyDown\n      },\n      floating: {\n        onKeyDown\n      }\n    };\n  }, [enabled, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch]);\n};\nexport { FloatingDelayGroup, FloatingFocusManager, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, inner, safePolygon, useClick, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInnerOffset, useInteractions, useListNavigation, useRole, useTypeahead };","map":{"version":3,"names":["useFloating","useFloating$1","offset","detectOverflow","getOverflowAncestors","React","useLayoutEffect","useEffect","useRef","createPortal","flushSync","tabbable","hideOthers","index","document","createPubSub","map","Map","emit","event","data","_map$get","get","forEach","handler","on","listener","set","off","filter","l","serverHandoffComplete","count","genId","useFloatingId","id","setId","useState","undefined","useReactId","toString","useId","FloatingNodeContext","createContext","FloatingTreeContext","useFloatingParentNodeId","_React$useContext$id","_React$useContext","useContext","useFloatingTree","useFloatingNodeId","customParentId","tree","reactParentId","parentId","node","addNode","removeNode","FloatingNode","_ref","children","createElement","Provider","value","useMemo","FloatingTree","_ref2","nodesRef","useCallback","current","n","events","getDocument","floating","_floating$ownerDocume","ownerDocument","getPlatform","uaData","navigator","userAgentData","platform","getUserAgent","Array","isArray","brands","brand","version","join","userAgent","getWindow","_getDocument$defaultV","defaultView","window","isElement","Element","isHTMLElement","HTMLElement","isShadowRoot","ShadowRoot","OwnElement","isVirtualClick","mozInputSource","isTrusted","androidRe","test","pointerType","type","buttons","detail","isVirtualPointerEvent","width","height","pressure","isSafari","vendor","isMac","toLowerCase","startsWith","maxTouchPoints","useInsertionEffect","useSafeInsertionEffect","fn","useEvent","callback","ref","process","env","NODE_ENV","Error","_len","arguments","length","args","_key","_temp","open","onOpenChange","unstable_onOpenChange","whileElementsMounted","placement","middleware","strategy","nodeId","domReference","setDomReference","domReferenceRef","dataRef","position","refs","context","_","find","reference","setReference","mergeProps","userProps","propsList","elementKey","tabIndex","concat","reduce","acc","props","Object","entries","key","indexOf","has","push","_map$get2","useInteractions","deps","getReferenceProps","getFloatingProps","getItemProps","contains","parent","child","rootNode","getRootNode","next","parentNode","host","getChildren","nodes","_nodes$filter","allChildren","_node$context","currentChildren","_nodes$filter2","_currentChildren","some","_node$context2","getTarget","composedPath","target","isPointInPolygon","point","polygon","x","y","isInside","i","j","xi","yi","xj","yj","intersect","safePolygon","restMs","buffer","blockPointerEvents","debug","timeoutId","polygonIsDestroyed","onClose","leave","onMouseMove","clearTimeout","close","clientX","clientY","relatedTarget","refRect","getBoundingClientRect","rect","side","split","cursorLeaveFromRight","right","cursorLeaveFromBottom","bottom","top","left","getPolygon","_ref3","isFloatingWider","isFloatingTaller","cursorPointOne","cursorPointTwo","commonPoints","poly","slice","setTimeout","__options","_extends","assign","source","prototype","hasOwnProperty","call","apply","HIDDEN_STYLES","border","clip","margin","overflow","padding","whiteSpace","activeElement$1","setActiveElementOnTab","isTabFocus","result","FocusGuard","forwardRef","onFocus","role","setRole","addEventListener","removeEventListener","style","persist","activeElement","doc","_activeElement","_activeElement$shadow","shadowRoot","getTabbableOptions","getShadowRoot","displayCheck","ResizeObserver","includes","getTabbableIn","container","direction","allTabbable","reverse","activeIndex","nextTabbableElements","getNextTabbable","body","getPreviousTabbable","isOutsideEvent","containerElement","currentTarget","disableFocusInside","tabbableElements","element","_element$getAttribute","dataset","tabindex","getAttribute","setAttribute","enableFocusInside","elements","querySelectorAll","removeAttribute","PortalContext","useFloatingPortalNode","enabled","portalEl","setPortalEl","uniqueId","portalContext","usePortalContext","getElementById","newPortalEl","portalNode","appendChild","removeChild","FloatingPortal","root","preserveTabOrder","focusManagerState","setFocusManagerState","beforeOutsideRef","afterOutsideRef","beforeInsideRef","afterInsideRef","shouldRenderGuards","modal","focusing","manageFocus","_beforeInsideRef$curr","focus","prevTabbable","_afterInsideRef$curre","nextTabbable","identifier","FloatingOverlay","lockScroll","rest","_window$visualViewpor","_window$visualViewpor2","_window$visualViewpor3","_window$visualViewpor4","alreadyLocked","hasAttribute","scrollbarX","Math","round","documentElement","scrollLeft","paddingProp","scrollbarWidth","innerWidth","clientWidth","offsetLeft","visualViewport","offsetTop","scrollX","pageXOffset","scrollY","pageYOffset","floor","scrollTo","TYPEABLE_SELECTOR","isTypeableElement","matches","stopEvent","preventDefault","stopPropagation","useLatestRef","getAncestors","_nodes$find","allAncestors","currentParentId","currentNode","rafId","enqueueFocus","el","options","preventScroll","cancelPrevious","sync","cancelAnimationFrame","exec","requestAnimationFrame","VisuallyHiddenDismiss","FloatingFocusManager","order","guards","initialFocus","returnFocus","visuallyHiddenDismiss","orderRef","tabbableContentLength","setTabbableContentLength","initialFocusControlled","startDismissButtonRef","endDismissButtonRef","preventReturnFocusRef","previouslyFocusedElementRef","insidePortal","typeableCombobox","getTabbableContent","getTabbableElements","content","Boolean","flat","onKeyDown","els","shiftKey","_portalContext$portal","_portalContext$portal2","portalNodes","from","getDismissButtons","isPointerDown","handlePointerDown","handleFocusOutside","movedToUnrelatedNode","_node$context3","_node$context4","cleanup","insideNodes","tabIndexValues","floatingTabbable","returnFocusValue","preventReturnFocusScroll","previouslyFocusedElement","focusableElements","elToFocus","onDismiss","payload","renderDismissButton","location","onClick","Fragment","_portalContext$before","cloneElement","_portalContext$afterO","mouseLikePointerTypes","getDelay","prop","useHover","delay","handleClose","mouseOnly","move","handleCloseRef","delayRef","pointerTypeRef","timeoutRef","handlerRef","restTimeoutRef","blockMouseMoveRef","performedPointerEventsMutationRef","isHoverOpen","_dataRef$current$open","openEvent","onLeave","html","closeWithDelay","runElseBranch","closeDelay","cleanupMouseMoveHandler","clearPointerEvents","pointerEvents","isClickLikeOpenEvent","onMouseEnter","openDelay","onMouseLeave","onScrollMouseLeave","once","_tree$nodesRef$curren","_tree$nodesRef$curren2","parentFloating","setPointerRef","onPointerDown","onPointerEnter","FloatingDelayGroupContext","initialDelay","currentId","setCurrentId","setState","useDelayGroupContext","FloatingDelayGroup","state","useDelayGroup","getArgsWithCustomFloatingHeight","rects","inner","name","middlewareArguments","_scrollRef$current","listRef","overflowRef","onFallbackChange","innerOffset","minItemsVisible","referenceOverflowThreshold","scrollRef","detectOverflowOptions","item","console","warn","nextArgs","offsetHeight","scrollHeight","refOverflow","elementContext","diffY","max","nextY","maxHeight","scrollTop","min","useInnerOffset","onChange","unstable_onChange","controlledScrollingRef","prevScrollTopRef","initialOverflowRef","_scrollRef$current2","onWheel","e","ctrlKey","dY","deltaY","isAtTop","isAtBottom","remainingScroll","clientHeight","sign","method","d","onPointerMove","onScroll","scrollDiff","useRole","rootId","referenceId","floatingProps","isButtonTarget","tagName","isSpaceIgnored","useClick","eventOption","toggle","ignoreMouse","keyboardHandlers","onMouseDown","button","nativeEvent","onKeyUp","isEventTargetWithin","bubbleHandlerKeys","pointerdown","mousedown","click","captureHandlerKeys","useDismiss","escapeKey","outsidePress","outsidePressEvent","referencePress","referencePressEvent","ancestorScroll","bubbles","nested","outsidePressRef","insideReactTreeRef","onOutsidePress","insideReactTree","_refs$floating$curren","win","canScrollX","scrollWidth","canScrollY","xCond","offsetX","isRTL","getComputedStyle","offsetWidth","offsetY","targetIsInsideChildren","ancestors","contextElement","ancestor","_doc$defaultView","passive","useFocus","keyboardOnly","blockFocusRef","onBlur","movedToFocusGuard","isPreventScrollSupported","ARROW_UP","ARROW_DOWN","ARROW_LEFT","ARROW_RIGHT","isDifferentRow","cols","prevRow","isIndexOutOfBounds","findNonDisabledIndex","startingIndex","decrement","disabledIndices","amount","list","_list$index","_list$index2","doSwitch","orientation","vertical","horizontal","isMainOrientationKey","isMainOrientationToEndKey","rtl","isCrossOrientationOpenKey","isCrossOrientationCloseKey","getMinIndex","getMaxIndex","useListNavigation","_temp2","onNavigate","unstable_onNavigate","selectedIndex","allowEscape","loop","virtual","focusItemOnOpen","focusItemOnHover","openOnArrowKeyDown","focusItemOnOpenRef","indexRef","keyRef","blockPointerLeaveRef","previousOnNavigateRef","previousOpenRef","forceSyncFocus","disabledIndicesRef","latestOpenRef","activeId","setActiveId","focusItem","_listRef$current$inde","currentIndex","minIndex","maxIndex","prevIndex","col","maxCol","lastRow","checkVirtualMouse","checkVirtualPointer","isArrowKey","isNavigationKey","_ref4","onPointerLeave","useTypeahead","onMatch","unstable_onMatch","findMatch","resetMs","ignoreKeys","timeoutIdRef","stringRef","prevIndexRef","matchIndexRef","findMatchRef","ignoreKeysRef","closest","typing","listContent","metaKey","altKey","allowRapidSuccessionOfFirstLetter","every","text","_text$","_text$2","toLocaleLowerCase","orderedList","str"],"sources":["/home/ravi/npciV4/IGC-NPCI-HACKATHON/frontend/node_modules/@floating-ui/react-dom-interactions/dist/floating-ui.react-dom-interactions.esm.js"],"sourcesContent":["import { useFloating as useFloating$1, offset, detectOverflow, getOverflowAncestors } from '@floating-ui/react-dom';\nexport * from '@floating-ui/react-dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect, useRef } from 'react';\nimport { createPortal, flushSync } from 'react-dom';\nimport { tabbable } from 'tabbable';\nimport { hideOthers } from 'aria-hidden';\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n\n      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach(handler => handler(data));\n    },\n\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n\n    off(event, listener) {\n      map.set(event, (map.get(event) || []).filter(l => l !== listener));\n    }\n\n  };\n}\n\nlet serverHandoffComplete = false;\nlet count = 0;\n\nconst genId = () => \"floating-ui-\" + count++;\n\nfunction useFloatingId() {\n  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : undefined);\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  React.useEffect(() => {\n    if (!serverHandoffComplete) {\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id;\n} // `toString()` prevents bundlers from trying to `import { useId } from 'react'`\n\n\nconst useReactId = React[/*#__PURE__*/'useId'.toString()];\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/useId\n */\n\nconst useId = useReactId != null ? useReactId : useFloatingId;\n\nconst FloatingNodeContext = /*#__PURE__*/React.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/React.createContext(null);\nconst useFloatingParentNodeId = () => {\n  var _React$useContext$id, _React$useContext;\n\n  return (_React$useContext$id = (_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) != null ? _React$useContext$id : null;\n};\nconst useFloatingTree = () => React.useContext(FloatingTreeContext);\n/**\n * Registers a node into the floating tree, returning its id.\n */\n\nconst useFloatingNodeId = customParentId => {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null ? void 0 : tree.addNode(node);\n    return () => {\n      tree == null ? void 0 : tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n};\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\n\nconst FloatingNode = _ref => {\n  let {\n    children,\n    id\n  } = _ref;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/React.createElement(FloatingNodeContext.Provider, {\n    value: React.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n};\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM (i.e. portalled to a common node, rather than their\n * respective parent).\n * @see https://floating-ui.com/docs/FloatingTree\n */\n\nconst FloatingTree = _ref2 => {\n  let {\n    children\n  } = _ref2;\n  const nodesRef = React.useRef([]);\n  const addNode = React.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = React.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = React.useState(() => createPubSub())[0];\n  return /*#__PURE__*/React.createElement(FloatingTreeContext.Provider, {\n    value: React.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [nodesRef, addNode, removeNode, events])\n  }, children);\n};\n\nfunction getDocument(floating) {\n  var _floating$ownerDocume;\n\n  return (_floating$ownerDocume = floating == null ? void 0 : floating.ownerDocument) != null ? _floating$ownerDocume : document;\n}\n\n// Avoid Chrome DevTools blue warning\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n\n  return navigator.platform;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(_ref => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n\nfunction getWindow(value) {\n  var _getDocument$defaultV;\n\n  return (_getDocument$defaultV = getDocument(value).defaultView) != null ? _getDocument$defaultV : window;\n}\n\nfunction isElement(value) {\n  return value ? value instanceof getWindow(value).Element : false;\n}\nfunction isHTMLElement(value) {\n  return value ? value instanceof getWindow(value).HTMLElement : false;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n} // License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\n\nfunction isVirtualClick(event) {\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n\n  const androidRe = /Android/i;\n\n  if ((androidRe.test(getPlatform()) || androidRe.test(getUserAgent())) && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n\n  return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n  return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType !== 'mouse' || // iOS VoiceOver returns 0.333â€¢ for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;\n}\nfunction isSafari() {\n  // Chrome DevTools does not complain about navigator.vendor\n  return /apple/i.test(navigator.vendor);\n}\nfunction isMac() {\n  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n}\n\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = React[/*#__PURE__*/'useInsertionEffect'.toString()];\n\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\n\nfunction useEvent(callback) {\n  const ref = React.useRef(() => {\n    if (process.env.NODE_ENV !== \"production\") {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\n\nfunction useFloating(_temp) {\n  let {\n    open = false,\n    onOpenChange: unstable_onOpenChange,\n    whileElementsMounted,\n    placement,\n    middleware,\n    strategy,\n    nodeId\n  } = _temp === void 0 ? {} : _temp;\n  const [domReference, setDomReference] = React.useState(null);\n  const tree = useFloatingTree();\n  const domReferenceRef = React.useRef(null);\n  const dataRef = React.useRef({});\n  const events = React.useState(() => createPubSub())[0];\n  const position = useFloating$1({\n    placement,\n    middleware,\n    strategy,\n    whileElementsMounted\n  });\n  const onOpenChange = useEvent(unstable_onOpenChange);\n  const refs = React.useMemo(() => ({ ...position.refs,\n    domReference: domReferenceRef\n  }), [position.refs]);\n  const context = React.useMemo(() => ({ ...position,\n    refs,\n    dataRef,\n    nodeId,\n    events,\n    open,\n    onOpenChange,\n    _: {\n      domReference\n    }\n  }), [position, nodeId, events, open, onOpenChange, refs, domReference]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n\n    if (node) {\n      node.context = context;\n    }\n  });\n  const {\n    reference\n  } = position;\n  const setReference = React.useCallback(node => {\n    if (isElement(node) || node === null) {\n      context.refs.domReference.current = node;\n      setDomReference(node);\n    }\n\n    reference(node);\n  }, [reference, context.refs]);\n  return React.useMemo(() => ({ ...position,\n    context,\n    refs,\n    reference: setReference\n  }), [position, refs, context, setReference]);\n}\n\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  return { ...(elementKey === 'floating' && {\n      tabIndex: -1\n    }),\n    ...userProps,\n    ...propsList.map(value => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n\n      Object.entries(props).forEach(_ref => {\n        let [key, value] = _ref;\n\n        if (key.indexOf('on') === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n\n          if (typeof value === 'function') {\n            var _map$get;\n\n            (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);\n\n            acc[key] = function () {\n              var _map$get2;\n\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n\n              (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.forEach(fn => fn(...args));\n            };\n          }\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\n\nconst useInteractions = function (propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n\n  // The dependencies are a dynamic array, so we can't use the linter's\n  // suggestion to add it to the deps array.\n  const deps = propsList;\n  const getReferenceProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'reference'), // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getFloatingProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'floating'), // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getItemProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'item'), // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  return React.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n};\n\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n\n  const rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  } // Give up, the result is false\n\n\n  return false;\n}\n\nfunction getChildren(nodes, id) {\n  var _nodes$filter;\n\n  let allChildren = (_nodes$filter = nodes.filter(node => {\n    var _node$context;\n\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  })) != null ? _nodes$filter : [];\n  let currentChildren = allChildren;\n\n  while (currentChildren.length) {\n    var _nodes$filter2;\n\n    currentChildren = (_nodes$filter2 = nodes.filter(node => {\n      var _currentChildren;\n\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    })) != null ? _nodes$filter2 : [];\n    allChildren = allChildren.concat(currentChildren);\n  }\n\n  return allChildren;\n}\n\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  } // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n\n\n  return event.target;\n}\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n\n  return isInside;\n}\n\nfunction safePolygon(_temp) {\n  let {\n    restMs = 0,\n    buffer = 0.5,\n    blockPointerEvents = true,\n    debug = null\n  } = _temp === void 0 ? {} : _temp;\n  let timeoutId;\n  let polygonIsDestroyed = false;\n\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      refs,\n      onClose,\n      nodeId,\n      tree,\n      leave = false\n    } = _ref;\n    return function onMouseMove(event) {\n      clearTimeout(timeoutId);\n\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n\n      const {\n        clientX,\n        clientY\n      } = event;\n      const target = getTarget(event); // If the pointer is over the reference, there is no need to run the logic\n\n      if (event.type === 'mousemove' && contains(refs.domReference.current, target)) {\n        return;\n      } // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n\n\n      if (event.type === 'mouseleave' && isElement(event.relatedTarget) && contains(refs.floating.current, event.relatedTarget)) {\n        return;\n      } // If any nested child is open, abort.\n\n\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      } // The cursor landed, so we destroy the polygon logic\n\n\n      if (contains(refs.floating.current, target) && !leave) {\n        polygonIsDestroyed = true;\n        return;\n      }\n\n      if (!refs.domReference.current || !refs.floating.current || placement == null || x == null || y == null) {\n        return;\n      }\n\n      const refRect = refs.domReference.current.getBoundingClientRect();\n      const rect = refs.floating.current.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2; // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      } // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n\n\n      switch (side) {\n        case 'top':\n          if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= refRect.top + 1) {\n            return;\n          }\n\n          break;\n\n        case 'bottom':\n          if (clientX >= rect.left && clientX <= rect.right && clientY >= refRect.bottom - 1 && clientY <= rect.bottom) {\n            return;\n          }\n\n          break;\n\n        case 'left':\n          if (clientX >= rect.left && clientX <= refRect.left + 1 && clientY >= rect.top && clientY <= rect.bottom) {\n            return;\n          }\n\n          break;\n\n        case 'right':\n          if (clientX >= refRect.right - 1 && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {\n            return;\n          }\n\n          break;\n      }\n\n      if (polygonIsDestroyed) {\n        return close();\n      }\n\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        const isFloatingWider = rect.width > refRect.width;\n        const isFloatingTaller = rect.height > refRect.height;\n\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n\n      const poly = getPolygon([x, y]);\n\n      if (process.env.NODE_ENV !== \"production\") {\n        debug == null ? void 0 : debug(poly.slice(0, 4).join(', '));\n      }\n\n      if (!isPointInPolygon([clientX, clientY], poly)) {\n        close();\n      } else if (restMs) {\n        timeoutId = setTimeout(onClose, restMs);\n      }\n    };\n  };\n\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nlet activeElement$1;\nlet timeoutId;\n\nfunction setActiveElementOnTab(event) {\n  if (event.key === 'Tab') {\n    activeElement$1 = event.target;\n    clearTimeout(timeoutId);\n  }\n}\n\nfunction isTabFocus(event) {\n  const result = activeElement$1 === event.relatedTarget;\n  activeElement$1 = event.relatedTarget;\n  clearTimeout(timeoutId);\n  return result;\n}\n\nconst FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref) {\n  const onFocus = useEvent(props.onFocus);\n  const [role, setRole] = React.useState();\n  index(() => {\n    if (isSafari()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n\n    document.addEventListener('keydown', setActiveElementOnTab);\n    return () => {\n      document.removeEventListener('keydown', setActiveElementOnTab);\n    };\n  }, []);\n  return /*#__PURE__*/React.createElement(\"span\", _extends({}, props, {\n    ref: ref,\n    tabIndex: 0 // Role is only for VoiceOver\n    ,\n    role: role,\n    \"aria-hidden\": role ? undefined : true,\n    \"data-floating-ui-focus-guard\": \"\",\n    style: HIDDEN_STYLES,\n    onFocus: event => {\n      if (isSafari() && isMac() && !isTabFocus(event)) {\n        // On macOS we need to wait a little bit before moving\n        // focus again.\n        event.persist();\n        timeoutId = window.setTimeout(() => {\n          onFocus(event);\n        }, 50);\n      } else {\n        onFocus(event);\n      }\n    }\n  }));\n});\n\n/**\n * Find the real active element. Traverses into shadowRoots.\n */\nfunction activeElement(doc) {\n  let activeElement = doc.activeElement;\n\n  while (((_activeElement = activeElement) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {\n    var _activeElement, _activeElement$shadow;\n\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n\n  return activeElement;\n}\n\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck: // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, direction) {\n  const allTabbable = tabbable(container, getTabbableOptions());\n\n  if (direction === 'prev') {\n    allTabbable.reverse();\n  }\n\n  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));\n  const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n  return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n  return getTabbableIn(document.body, 'next');\n}\nfunction getPreviousTabbable() {\n  return getTabbableIn(document.body, 'prev');\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = tabbable(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    var _element$getAttribute;\n\n    element.dataset.tabindex = (_element$getAttribute = element.getAttribute('tabindex')) != null ? _element$getAttribute : '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    delete element.dataset.tabindex;\n\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\n\nconst PortalContext = /*#__PURE__*/React.createContext(null);\nconst useFloatingPortalNode = function (_temp) {\n  let {\n    id,\n    enabled = true\n  } = _temp === void 0 ? {} : _temp;\n  const [portalEl, setPortalEl] = React.useState(null);\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n\n    const rootNode = id ? document.getElementById(id) : null;\n\n    if (rootNode) {\n      rootNode.setAttribute('data-floating-ui-portal', '');\n      setPortalEl(rootNode);\n    } else {\n      const newPortalEl = document.createElement('div');\n      newPortalEl.id = id || uniqueId;\n      newPortalEl.setAttribute('data-floating-ui-portal', '');\n      setPortalEl(newPortalEl);\n      const container = (portalContext == null ? void 0 : portalContext.portalNode) || document.body;\n      container.appendChild(newPortalEl);\n      return () => {\n        container.removeChild(newPortalEl);\n      };\n    }\n  }, [id, portalContext, uniqueId, enabled]);\n  return portalEl;\n};\n/**\n * Portals your floating element outside of the main app node.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\n\nconst FloatingPortal = _ref => {\n  let {\n    children,\n    id,\n    root = null,\n    preserveTabOrder = true\n  } = _ref;\n  const portalNode = useFloatingPortalNode({\n    id,\n    enabled: !root\n  });\n  const [focusManagerState, setFocusManagerState] = React.useState(null);\n  const beforeOutsideRef = React.useRef(null);\n  const afterOutsideRef = React.useRef(null);\n  const beforeInsideRef = React.useRef(null);\n  const afterInsideRef = React.useRef(null);\n  const shouldRenderGuards = // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState && // Guards are only for non-modal focus management.\n  !focusManagerState.modal && !!(root || portalNode) && preserveTabOrder; // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n\n  React.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n      return;\n    } // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n\n\n    function onFocus(event) {\n      if (portalNode && isOutsideEvent(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n        manageFocus(portalNode);\n      }\n    } // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n\n\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);\n  return /*#__PURE__*/React.createElement(PortalContext.Provider, {\n    value: React.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode])\n  }, shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    ref: beforeOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _beforeInsideRef$curr;\n\n        (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();\n      } else {\n        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        prevTabbable == null ? void 0 : prevTabbable.focus();\n      }\n    }\n  }), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-owns\": portalNode.id,\n    style: HIDDEN_STYLES\n  }), root ? /*#__PURE__*/createPortal(children, root) : portalNode ? /*#__PURE__*/createPortal(children, portalNode) : null, shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    ref: afterOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _afterInsideRef$curre;\n\n        (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();\n      } else {\n        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        nextTabbable == null ? void 0 : nextTabbable.focus();\n        focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false);\n      }\n    }\n  }));\n};\nconst usePortalContext = () => React.useContext(PortalContext);\n\nconst identifier = 'data-floating-ui-scroll-lock';\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\n\nconst FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(_ref, ref) {\n  let {\n    lockScroll = false,\n    ...rest\n  } = _ref;\n  index(() => {\n    var _window$visualViewpor, _window$visualViewpor2, _window$visualViewpor3, _window$visualViewpor4;\n\n    if (!lockScroll) {\n      return;\n    }\n\n    const alreadyLocked = document.body.hasAttribute(identifier);\n\n    if (alreadyLocked) {\n      return;\n    }\n\n    document.body.setAttribute(identifier, ''); // RTL <body> scrollbar\n\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth; // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n\n    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {\n      Object.assign(document.body.style, {\n        overflow: 'hidden',\n        [paddingProp]: scrollbarWidth + \"px\"\n      });\n      return () => {\n        document.body.removeAttribute(identifier);\n        Object.assign(document.body.style, {\n          overflow: '',\n          [paddingProp]: ''\n        });\n      };\n    } // iOS 12 does not support `visuaViewport`.\n\n\n    const offsetLeft = (_window$visualViewpor = (_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetLeft) != null ? _window$visualViewpor : 0;\n    const offsetTop = (_window$visualViewpor3 = (_window$visualViewpor4 = window.visualViewport) == null ? void 0 : _window$visualViewpor4.offsetTop) != null ? _window$visualViewpor3 : 0;\n    const scrollX = window.pageXOffset;\n    const scrollY = window.pageYOffset;\n    Object.assign(document.body.style, {\n      position: 'fixed',\n      overflow: 'hidden',\n      top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n      left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n      right: '0',\n      [paddingProp]: scrollbarWidth + \"px\"\n    });\n    return () => {\n      Object.assign(document.body.style, {\n        position: '',\n        overflow: '',\n        top: '',\n        left: '',\n        right: '',\n        [paddingProp]: ''\n      });\n      document.body.removeAttribute(identifier);\n      window.scrollTo(scrollX, scrollY);\n    };\n  }, [lockScroll]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: {\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...rest.style\n    }\n  }));\n});\n\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\n\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\n\nfunction useLatestRef(value) {\n  const ref = useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n\n  return allAncestors;\n}\n\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\n\nconst VisuallyHiddenDismiss = /*#__PURE__*/React.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/React.createElement(\"button\", _extends({}, props, {\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  }));\n});\n\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(_ref) {\n  let {\n    context,\n    children,\n    order = ['content'],\n    guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    modal = true,\n    visuallyHiddenDismiss = false\n  } = _ref;\n  const {\n    refs,\n    nodeId,\n    onOpenChange,\n    events,\n    _: {\n      domReference\n    }\n  } = context;\n  const orderRef = useLatestRef(order);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const [tabbableContentLength, setTabbableContentLength] = React.useState(null); // Controlled by `useListNavigation`.\n\n  const initialFocusControlled = typeof initialFocus === 'number' && initialFocus < 0;\n  const startDismissButtonRef = React.useRef(null);\n  const endDismissButtonRef = React.useRef(null);\n  const preventReturnFocusRef = React.useRef(false);\n  const previouslyFocusedElementRef = React.useRef(null);\n  const insidePortal = portalContext != null; // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n\n  const typeableCombobox = domReference && domReference.getAttribute('role') === 'combobox' && isTypeableElement(domReference);\n  const getTabbableContent = React.useCallback(function (container) {\n    if (container === void 0) {\n      container = refs.floating.current;\n    }\n\n    return container ? tabbable(container, getTabbableOptions()) : [];\n  }, [refs]);\n  const getTabbableElements = React.useCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (refs.domReference.current && type === 'reference') {\n        return refs.domReference.current;\n      }\n\n      if (refs.floating.current && type === 'floating') {\n        return refs.floating.current;\n      }\n\n      return content;\n    }).filter(Boolean).flat();\n  }, [orderRef, refs, getTabbableContent]);\n  React.useEffect(() => {\n    if (!modal) {\n      return;\n    }\n\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if (getTabbableContent().length === 0 && !typeableCombobox) {\n          stopEvent(event);\n        }\n\n        const els = getTabbableElements();\n        const target = getTarget(event);\n\n        if (orderRef.current[0] === 'reference' && target === refs.domReference.current) {\n          stopEvent(event);\n\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n\n        if (orderRef.current[1] === 'floating' && target === refs.floating.current && event.shiftKey) {\n          stopEvent(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n\n    const doc = getDocument(refs.floating.current);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [modal, orderRef, refs, typeableCombobox, getTabbableContent, getTabbableElements]);\n  React.useEffect(() => {\n    var _portalContext$portal, _portalContext$portal2;\n\n    const floating = refs.floating.current;\n    const reference = refs.domReference.current; // Don't hide portals nested within the parent portal.\n\n    const portalNodes = Array.from((_portalContext$portal = portalContext == null ? void 0 : (_portalContext$portal2 = portalContext.portalNode) == null ? void 0 : _portalContext$portal2.querySelectorAll('[data-floating-ui-portal]')) != null ? _portalContext$portal : []);\n\n    function getDismissButtons() {\n      return [startDismissButtonRef.current, endDismissButtonRef.current].filter(Boolean);\n    }\n\n    let isPointerDown = false; // In Safari, buttons lose focus when pressing them.\n\n    function handlePointerDown() {\n      isPointerDown = true;\n      setTimeout(() => {\n        isPointerDown = false;\n      });\n    }\n\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      const movedToUnrelatedNode = !(contains(reference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || [portalContext == null ? void 0 : portalContext.beforeOutsideRef.current, portalContext == null ? void 0 : portalContext.afterOutsideRef.current].filter(Boolean).includes(relatedTarget) || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n        var _node$context, _node$context2;\n\n        return contains((_node$context = node.context) == null ? void 0 : _node$context.refs.floating.current, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.refs.domReference.current, relatedTarget);\n      }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n        var _node$context3, _node$context4;\n\n        return ((_node$context3 = node.context) == null ? void 0 : _node$context3.refs.floating.current) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.refs.domReference.current) === relatedTarget;\n      }))); // Focus did not move inside the floating tree, and there are no tabbable\n      // portal guards to handle closing.\n\n      if (relatedTarget && movedToUnrelatedNode && !isPointerDown && // Fix React 18 Strict Mode returnFocus due to double rendering.\n      relatedTarget !== previouslyFocusedElementRef.current) {\n        preventReturnFocusRef.current = true; // On iOS VoiceOver, dismissing the nested submenu will cause the\n        // first item of the list to receive focus. Delaying it appears to fix\n        // the issue.\n\n        setTimeout(() => onOpenChange(false));\n      }\n    }\n\n    if (floating && isHTMLElement(reference)) {\n      let cleanup;\n\n      if (modal) {\n        const insideNodes = [floating, ...portalNodes, ...getDismissButtons()];\n        cleanup = hideOthers(orderRef.current.includes('reference') || typeableCombobox ? insideNodes.concat(reference) : insideNodes);\n      }\n\n      reference.addEventListener('focusout', handleFocusOutside);\n      reference.addEventListener('pointerdown', handlePointerDown);\n      !modal && floating.addEventListener('focusout', handleFocusOutside);\n      return () => {\n        reference.removeEventListener('focusout', handleFocusOutside);\n        reference.removeEventListener('pointerdown', handlePointerDown);\n        !modal && floating.removeEventListener('focusout', handleFocusOutside);\n        cleanup == null ? void 0 : cleanup();\n      };\n    }\n  }, [modal, initialFocus, nodeId, tree, orderRef, refs, portalContext, typeableCombobox, initialFocusControlled, onOpenChange]);\n  React.useEffect(() => {\n    const floating = refs.floating.current;\n\n    if (modal && !guards && floating) {\n      const tabIndexValues = [];\n      const options = getTabbableOptions();\n      const allTabbable = tabbable(getDocument(floating).body, options);\n      const floatingTabbable = getTabbableElements(); // Exclude all tabbable elements that are part of the order\n\n      const elements = allTabbable.filter(el => !floatingTabbable.includes(el));\n      elements.forEach((el, i) => {\n        tabIndexValues[i] = el.getAttribute('tabindex');\n        el.setAttribute('tabindex', '-1');\n      });\n      return () => {\n        elements.forEach((el, i) => {\n          const value = tabIndexValues[i];\n\n          if (value == null) {\n            el.removeAttribute('tabindex');\n          } else {\n            el.setAttribute('tabindex', value);\n          }\n        });\n      };\n    }\n  }, [modal, guards, refs, getTabbableElements]); // Layout effect to ensure that the previouslyFocusedElement is set before\n  // focus is moved inside the floating element via hooks like\n  // useListNavigation.\n\n  index(() => {\n    const floating = refs.floating.current;\n\n    if (!floating) {\n      return;\n    }\n\n    const doc = getDocument(floating);\n    let returnFocusValue = returnFocus;\n    let preventReturnFocusScroll = false;\n    const previouslyFocusedElement = activeElement(doc);\n    previouslyFocusedElementRef.current = previouslyFocusedElement;\n    const focusableElements = getTabbableElements(floating);\n    const elToFocus = (typeof initialFocus === 'number' ? focusableElements[initialFocus] : initialFocus.current) || floating; // If the `useListNavigation` hook is active, always ignore `initialFocus`\n    // because it has its own handling of the initial focus.\n\n    !initialFocusControlled && enqueueFocus(elToFocus, {\n      preventScroll: elToFocus === floating\n    }); // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n\n    function onDismiss(payload) {\n      if (payload.type === 'escapeKey' && refs.domReference.current) {\n        previouslyFocusedElementRef.current = refs.domReference.current;\n      }\n\n      if (payload.type !== 'outsidePress') {\n        return;\n      }\n\n      const returnFocus = payload.data.returnFocus;\n\n      if (typeof returnFocus === 'object') {\n        returnFocusValue = true;\n        preventReturnFocusScroll = returnFocus.preventScroll;\n      } else {\n        returnFocusValue = returnFocus;\n      }\n    }\n\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n\n      if (contains(floating, activeElement(doc)) && refs.domReference.current) {\n        previouslyFocusedElementRef.current = refs.domReference.current;\n      }\n\n      if (returnFocusValue && isHTMLElement(previouslyFocusedElementRef.current) && !preventReturnFocusRef.current) {\n        enqueueFocus(previouslyFocusedElementRef.current, {\n          preventScroll: preventReturnFocusScroll,\n          // When dismissing nested floating elements, by the time the rAF has\n          // executed, the menus will all have been unmounted. When they try\n          // to get focused, the calls get ignored â€” leaving the root reference\n          // focused as desired.\n          cancelPrevious: false\n        });\n      }\n    };\n  }, [getTabbableElements, initialFocus, returnFocus, refs, events, initialFocusControlled]); // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n\n  index(() => {\n    if (!portalContext) return;\n    portalContext.setFocusManagerState({ ...context,\n      modal // Not concerned about the <RT> generic type.\n\n    });\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [portalContext, modal, context]);\n  index(() => {\n    if (getTabbableContent().length === 0 && !initialFocusControlled) {\n      setTabbableContentLength(0);\n    }\n  }, [getTabbableContent, refs, initialFocusControlled]);\n  const shouldRenderGuards = guards && (insidePortal || modal) && !typeableCombobox;\n\n  function renderDismissButton(location) {\n    return visuallyHiddenDismiss && modal ? /*#__PURE__*/React.createElement(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: () => onOpenChange(false)\n    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss') : null;\n  }\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n    onFocus: event => {\n      if (modal) {\n        const els = getTabbableElements();\n        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = false;\n\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const nextTabbable = getNextTabbable() || domReference;\n          nextTabbable == null ? void 0 : nextTabbable.focus();\n        } else {\n          var _portalContext$before;\n\n          (_portalContext$before = portalContext.beforeOutsideRef.current) == null ? void 0 : _portalContext$before.focus();\n        }\n      }\n    }\n  }), typeableCombobox ? null : renderDismissButton('start'), /*#__PURE__*/React.cloneElement(children, tabbableContentLength === 0 || order.includes('floating') ? {\n    tabIndex: 0\n  } : {}), renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n    onFocus: event => {\n      if (modal) {\n        enqueueFocus(getTabbableElements()[0]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = true;\n\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const prevTabbable = getPreviousTabbable() || domReference;\n          prevTabbable == null ? void 0 : prevTabbable.focus();\n        } else {\n          var _portalContext$afterO;\n\n          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null ? void 0 : _portalContext$afterO.focus();\n        }\n      }\n    }\n  }));\n}\n\n// On some Linux machines with Chromium, mouse inputs return a `pointerType` of\n// \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\nconst mouseLikePointerTypes = ['mouse', 'pen', '', undefined];\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !mouseLikePointerTypes.includes(pointerType)) {\n    return 0;\n  }\n\n  if (typeof value === 'number') {\n    return value;\n  }\n\n  return value == null ? void 0 : value[prop];\n}\n\n/**\n * Adds hover event listeners that change the open state, like CSS :hover.\n * @see https://floating-ui.com/docs/useHover\n */\nconst useHover = function (context, _temp) {\n  let {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = _temp === void 0 ? {} : _temp;\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    refs,\n    _\n  } = context;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = useLatestRef(handleClose);\n  const delayRef = useLatestRef(delay);\n  const pointerTypeRef = React.useRef();\n  const timeoutRef = React.useRef();\n  const handlerRef = React.useRef();\n  const restTimeoutRef = React.useRef();\n  const blockMouseMoveRef = React.useRef(true);\n  const performedPointerEventsMutationRef = React.useRef(false);\n  const isHoverOpen = React.useCallback(() => {\n    var _dataRef$current$open;\n\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  }, [dataRef]); // When dismissing before opening, clear the delay timeouts to cancel it\n  // from showing.\n\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    function onDismiss() {\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      blockMouseMoveRef.current = true;\n    }\n\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [enabled, events, refs]);\n  React.useEffect(() => {\n    if (!enabled || !handleCloseRef.current || !open) {\n      return;\n    }\n\n    function onLeave() {\n      if (isHoverOpen()) {\n        onOpenChange(false);\n      }\n    }\n\n    const html = getDocument(refs.floating.current).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [refs, open, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);\n  const closeWithDelay = React.useCallback(function (runElseBranch) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => onOpenChange(false), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChange(false);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = React.useCallback(() => {\n    if (handlerRef.current) {\n      getDocument(refs.floating.current).removeEventListener('mousemove', handlerRef.current);\n      handlerRef.current = undefined;\n    }\n  }, [refs]);\n  const clearPointerEvents = React.useCallback(() => {\n    getDocument(refs.floating.current).body.style.pointerEvents = '';\n    performedPointerEventsMutationRef.current = false;\n  }, [refs]); // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    function isClickLikeOpenEvent() {\n      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n    }\n\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n\n      if (mouseOnly && !mouseLikePointerTypes.includes(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {\n        return;\n      }\n\n      dataRef.current.openEvent = event;\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n\n      if (openDelay) {\n        timeoutRef.current = setTimeout(() => {\n          onOpenChange(true);\n        }, openDelay);\n      } else {\n        onOpenChange(true);\n      }\n    }\n\n    function onMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n\n      const doc = getDocument(refs.floating.current);\n      clearTimeout(restTimeoutRef.current);\n\n      if (handleCloseRef.current) {\n        clearTimeout(timeoutRef.current);\n        handlerRef.current && doc.removeEventListener('mousemove', handlerRef.current);\n        handlerRef.current = handleCloseRef.current({ ...context,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            closeWithDelay();\n          }\n\n        });\n        doc.addEventListener('mousemove', handlerRef.current);\n        return;\n      }\n\n      closeWithDelay();\n    } // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n\n\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n\n      handleCloseRef.current == null ? void 0 : handleCloseRef.current({ ...context,\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        leave: true,\n\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          closeWithDelay();\n        }\n\n      })(event);\n    }\n\n    const floating = refs.floating.current;\n    const reference = refs.domReference.current;\n\n    if (isElement(reference)) {\n      open && reference.addEventListener('mouseleave', onScrollMouseLeave);\n      floating == null ? void 0 : floating.addEventListener('mouseleave', onScrollMouseLeave);\n      move && reference.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      reference.addEventListener('mouseenter', onMouseEnter);\n      reference.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        open && reference.removeEventListener('mouseleave', onScrollMouseLeave);\n        floating == null ? void 0 : floating.removeEventListener('mouseleave', onScrollMouseLeave);\n        move && reference.removeEventListener('mousemove', onMouseEnter);\n        reference.removeEventListener('mouseenter', onMouseEnter);\n        reference.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [// Ensure the effect is re-run when the reference changes.\n  // https://github.com/floating-ui/floating-ui/issues/1833\n  _.domReference, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, refs, delayRef, handleCloseRef, dataRef]); // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (open && handleCloseRef.current && handleCloseRef.current.__options.blockPointerEvents && isHoverOpen()) {\n      getDocument(refs.floating.current).body.style.pointerEvents = 'none';\n      performedPointerEventsMutationRef.current = true;\n      const reference = refs.domReference.current;\n      const floating = refs.floating.current;\n\n      if (isElement(reference) && floating) {\n        var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n\n        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.refs.floating.current;\n\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n\n        reference.style.pointerEvents = 'auto';\n        floating.style.pointerEvents = 'auto';\n        return () => {\n          reference.style.pointerEvents = '';\n          floating.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, refs, tree, handleCloseRef, dataRef, isHoverOpen]);\n  index(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      cleanupMouseMoveHandler();\n\n      if (performedPointerEventsMutationRef.current) {\n        clearPointerEvents();\n      }\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n  React.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n\n      if (performedPointerEventsMutationRef.current) {\n        clearPointerEvents();\n      }\n    };\n  }, [enabled, cleanupMouseMoveHandler, clearPointerEvents]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n\n    return {\n      reference: {\n        onPointerDown: setPointerRef,\n        onPointerEnter: setPointerRef,\n\n        onMouseMove() {\n          if (open || restMs === 0) {\n            return;\n          }\n\n          clearTimeout(restTimeoutRef.current);\n          restTimeoutRef.current = setTimeout(() => {\n            if (!blockMouseMoveRef.current) {\n              onOpenChange(true);\n            }\n          }, restMs);\n        }\n\n      },\n      floating: {\n        onMouseEnter() {\n          clearTimeout(timeoutRef.current);\n        },\n\n        onMouseLeave() {\n          closeWithDelay(false);\n        }\n\n      }\n    };\n  }, [enabled, restMs, open, onOpenChange, closeWithDelay]);\n};\n\nconst FloatingDelayGroupContext = /*#__PURE__*/React.createContext({\n  delay: 1000,\n  initialDelay: 1000,\n  currentId: null,\n  setCurrentId: () => {},\n  setState: () => {}\n});\nconst useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\n\nconst FloatingDelayGroup = _ref => {\n  let {\n    children,\n    delay\n  } = _ref;\n  const [state, setState] = React.useState({\n    delay,\n    initialDelay: delay,\n    currentId: null\n  });\n  const setCurrentId = React.useCallback(currentId => {\n    setState(state => ({ ...state,\n      currentId\n    }));\n  }, []);\n  return /*#__PURE__*/React.createElement(FloatingDelayGroupContext.Provider, {\n    value: React.useMemo(() => ({ ...state,\n      setState,\n      setCurrentId\n    }), [state, setState, setCurrentId])\n  }, children);\n};\nconst useDelayGroup = (_ref2, _ref3) => {\n  let {\n    open,\n    onOpenChange\n  } = _ref2;\n  let {\n    id\n  } = _ref3;\n  const {\n    currentId,\n    initialDelay,\n    setState\n  } = useDelayGroupContext();\n  React.useEffect(() => {\n    if (currentId) {\n      setState(state => ({ ...state,\n        delay: {\n          open: 1,\n          close: getDelay(initialDelay, 'close')\n        }\n      }));\n\n      if (currentId !== id) {\n        onOpenChange(false);\n      }\n    }\n  }, [id, onOpenChange, setState, currentId, initialDelay]);\n  React.useEffect(() => {\n    if (!open && currentId === id) {\n      onOpenChange(false);\n      setState(state => ({ ...state,\n        delay: initialDelay,\n        currentId: null\n      }));\n    }\n  }, [open, setState, currentId, id, onOpenChange, initialDelay]);\n};\n\nfunction getArgsWithCustomFloatingHeight(args, height) {\n  return { ...args,\n    rects: { ...args.rects,\n      floating: { ...args.rects.floating,\n        height\n      }\n    }\n  };\n}\n\nconst inner = options => ({\n  name: 'inner',\n  options,\n\n  async fn(middlewareArguments) {\n    var _scrollRef$current;\n\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = options;\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = middlewareArguments;\n    const item = listRef.current[index];\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!middlewareArguments.placement.startsWith('bottom')) {\n        console.warn(['Floating UI: `placement` side must be \"bottom\" when using the', '`inner` middleware.'].join(' '));\n      }\n    }\n\n    if (!item) {\n      return {};\n    }\n\n    const nextArgs = { ...middlewareArguments,\n      ...(await offset(-item.offsetTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(middlewareArguments))\n    };\n    const el = (_scrollRef$current = scrollRef == null ? void 0 : scrollRef.current) != null ? _scrollRef$current : floating;\n    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n    const refOverflow = await detectOverflow(nextArgs, { ...detectOverflowOptions,\n      elementContext: 'reference'\n    });\n    const diffY = Math.max(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n    el.style.maxHeight = maxHeight + \"px\";\n    el.scrollTop = diffY; // There is not enough space, fallback to standard anchored positioning\n\n    if (onFallbackChange) {\n      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n        flushSync(() => onFallbackChange(true));\n      } else {\n        flushSync(() => onFallbackChange(false));\n      }\n    }\n\n    if (overflowRef) {\n      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({ ...nextArgs,\n        y: nextY\n      }, el.offsetHeight), detectOverflowOptions);\n    }\n\n    return {\n      y: nextY\n    };\n  }\n\n});\nconst useInnerOffset = (_ref, _ref2) => {\n  let {\n    open,\n    refs\n  } = _ref;\n  let {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = _ref2;\n  const onChange = useEvent(unstable_onChange);\n  const controlledScrollingRef = React.useRef(false);\n  const prevScrollTopRef = React.useRef(null);\n  const initialOverflowRef = React.useRef(null);\n  React.useEffect(() => {\n    var _scrollRef$current2;\n\n    if (!enabled) {\n      return;\n    }\n\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        flushSync(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test(getUserAgent())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n\n    const el = (_scrollRef$current2 = scrollRef == null ? void 0 : scrollRef.current) != null ? _scrollRef$current2 : refs.floating.current;\n\n    if (open && el) {\n      el.addEventListener('wheel', onWheel); // Wait for the position to be ready.\n\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = { ...overflowRef.current\n          };\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, refs, overflowRef, scrollRef, onChange]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n\n    return {\n      floating: {\n        onKeyDown() {\n          controlledScrollingRef.current = true;\n        },\n\n        onWheel() {\n          controlledScrollingRef.current = false;\n        },\n\n        onPointerMove() {\n          controlledScrollingRef.current = false;\n        },\n\n        onScroll() {\n          const el = (scrollRef == null ? void 0 : scrollRef.current) || refs.floating.current;\n\n          if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n            return;\n          }\n\n          if (prevScrollTopRef.current !== null) {\n            const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n\n            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n              flushSync(() => onChange(d => d + scrollDiff));\n            }\n          } // [Firefox] Wait for the height change to have been applied.\n\n\n          requestAnimationFrame(() => {\n            prevScrollTopRef.current = el.scrollTop;\n          });\n        }\n\n      }\n    };\n  }, [enabled, overflowRef, refs, scrollRef, onChange]);\n};\n\n/**\n * Adds relevant screen reader props for a given element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nconst useRole = function (_ref, _temp) {\n  let {\n    open\n  } = _ref;\n  let {\n    enabled = true,\n    role = 'dialog'\n  } = _temp === void 0 ? {} : _temp;\n  const rootId = useId();\n  const referenceId = useId();\n  return React.useMemo(() => {\n    const floatingProps = {\n      id: rootId,\n      role\n    };\n\n    if (!enabled) {\n      return {};\n    }\n\n    if (role === 'tooltip') {\n      return {\n        reference: {\n          'aria-describedby': open ? rootId : undefined\n        },\n        floating: floatingProps\n      };\n    }\n\n    return {\n      reference: {\n        'aria-expanded': open ? 'true' : 'false',\n        'aria-haspopup': role === 'alertdialog' ? 'dialog' : role,\n        'aria-controls': open ? rootId : undefined,\n        ...(role === 'listbox' && {\n          role: 'combobox'\n        }),\n        ...(role === 'menu' && {\n          id: referenceId\n        })\n      },\n      floating: { ...floatingProps,\n        ...(role === 'menu' && {\n          'aria-labelledby': referenceId\n        })\n      }\n    };\n  }, [enabled, role, open, rootId, referenceId]);\n};\n\nfunction isButtonTarget(event) {\n  return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';\n}\n\nfunction isSpaceIgnored(element) {\n  return isTypeableElement(element);\n}\n\n/**\n * Adds click event listeners that change the open state.\n * @see https://floating-ui.com/docs/useClick\n */\nconst useClick = function (_ref, _temp) {\n  let {\n    open,\n    onOpenChange,\n    dataRef,\n    refs\n  } = _ref;\n  let {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true\n  } = _temp === void 0 ? {} : _temp;\n  const pointerTypeRef = React.useRef();\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n\n    return {\n      reference: {\n        onPointerDown(event) {\n          pointerTypeRef.current = event.pointerType;\n        },\n\n        onMouseDown(event) {\n          // Ignore all buttons except for the \"main\" button.\n          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n          if (event.button !== 0) {\n            return;\n          }\n\n          if (pointerTypeRef.current === 'mouse' && ignoreMouse) {\n            return;\n          }\n\n          if (eventOption === 'click') {\n            return;\n          }\n\n          if (open) {\n            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n              onOpenChange(false);\n            }\n          } else {\n            // Prevent stealing focus from the floating element\n            event.preventDefault();\n            onOpenChange(true);\n          }\n\n          dataRef.current.openEvent = event.nativeEvent;\n        },\n\n        onClick(event) {\n          if (eventOption === 'mousedown' && pointerTypeRef.current) {\n            pointerTypeRef.current = undefined;\n            return;\n          }\n\n          if (pointerTypeRef.current === 'mouse' && ignoreMouse) {\n            return;\n          }\n\n          if (open) {\n            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n              onOpenChange(false);\n            }\n          } else {\n            onOpenChange(true);\n          }\n\n          dataRef.current.openEvent = event.nativeEvent;\n        },\n\n        onKeyDown(event) {\n          pointerTypeRef.current = undefined;\n\n          if (!keyboardHandlers) {\n            return;\n          }\n\n          if (isButtonTarget(event)) {\n            return;\n          }\n\n          if (event.key === ' ' && !isSpaceIgnored(refs.domReference.current)) {\n            // Prevent scrolling\n            event.preventDefault();\n          }\n\n          if (event.key === 'Enter') {\n            if (open) {\n              if (toggle) {\n                onOpenChange(false);\n              }\n            } else {\n              onOpenChange(true);\n            }\n          }\n        },\n\n        onKeyUp(event) {\n          if (!keyboardHandlers) {\n            return;\n          }\n\n          if (isButtonTarget(event) || isSpaceIgnored(refs.domReference.current)) {\n            return;\n          }\n\n          if (event.key === ' ') {\n            if (open) {\n              if (toggle) {\n                onOpenChange(false);\n              }\n            } else {\n              onOpenChange(true);\n            }\n          }\n        }\n\n      }\n    };\n  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, refs, toggle, open, onOpenChange]);\n};\n\n/**\n * Check whether the event.target is within the provided node. Uses event.composedPath if available for custom element support.\n *\n * @param event The event whose target/composedPath to check\n * @param node The node to check against\n * @returns Whether the event.target/composedPath is within the node.\n */\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  } // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n\n\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\n\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\n\n/**\n * Adds listeners that dismiss (close) the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nconst useDismiss = function (_ref, _temp) {\n  let {\n    open,\n    onOpenChange,\n    refs,\n    events,\n    nodeId\n  } = _ref;\n  let {\n    enabled = true,\n    escapeKey = true,\n    outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles = true\n  } = _temp === void 0 ? {} : _temp;\n  const tree = useFloatingTree();\n  const nested = useFloatingParentNodeId() != null;\n  const outsidePressRef = useLatestRef(outsidePress);\n  const insideReactTreeRef = React.useRef(false);\n  React.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n\n    const outsidePress = outsidePressRef.current;\n\n    function onKeyDown(event) {\n      if (event.key === 'Escape') {\n        if (!bubbles && tree && getChildren(tree.nodesRef.current, nodeId).length > 0) {\n          return;\n        }\n\n        events.emit('dismiss', {\n          type: 'escapeKey',\n          data: {\n            returnFocus: {\n              preventScroll: false\n            }\n          }\n        });\n        onOpenChange(false);\n      }\n    }\n\n    function onOutsidePress(event) {\n      // Given developers can stop the propagation of the synthetic event,\n      // we can only be confident with a positive value.\n      const insideReactTree = insideReactTreeRef.current;\n      insideReactTreeRef.current = false;\n\n      if (insideReactTree) {\n        return;\n      }\n\n      if (typeof outsidePress === 'function' && !outsidePress(event)) {\n        return;\n      }\n\n      const target = getTarget(event); // Check if the click occurred on the scrollbar\n\n      if (isElement(target) && refs.floating.current) {\n        var _refs$floating$curren;\n\n        const win = (_refs$floating$curren = refs.floating.current.ownerDocument.defaultView) != null ? _refs$floating$curren : window;\n        const canScrollX = target.scrollWidth > target.clientWidth;\n        const canScrollY = target.scrollHeight > target.clientHeight;\n        let xCond = canScrollY && event.offsetX > target.clientWidth; // In some browsers it is possible to change the <body> (or window)\n        // scrollbar to the left side, but is very rare and is difficult to\n        // check for. Plus, for modal dialogs with backdrops, it is more\n        // important that the backdrop is checked but not so much the window.\n\n        if (canScrollY) {\n          const isRTL = win.getComputedStyle(target).direction === 'rtl';\n\n          if (isRTL) {\n            xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n          }\n        }\n\n        if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n          return;\n        }\n      }\n\n      const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context;\n\n        return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.refs.floating.current);\n      });\n\n      if (isEventTargetWithin(event, refs.floating.current) || isEventTargetWithin(event, refs.domReference.current) || targetIsInsideChildren) {\n        return;\n      }\n\n      if (!bubbles && tree && getChildren(tree.nodesRef.current, nodeId).length > 0) {\n        return;\n      }\n\n      events.emit('dismiss', {\n        type: 'outsidePress',\n        data: {\n          returnFocus: nested ? {\n            preventScroll: true\n          } : isVirtualClick(event) || isVirtualPointerEvent(event)\n        }\n      });\n      onOpenChange(false);\n    }\n\n    function onScroll() {\n      onOpenChange(false);\n    }\n\n    const doc = getDocument(refs.floating.current);\n    escapeKey && doc.addEventListener('keydown', onKeyDown);\n    outsidePress && doc.addEventListener(outsidePressEvent, onOutsidePress);\n    let ancestors = [];\n\n    if (ancestorScroll) {\n      if (isElement(refs.domReference.current)) {\n        ancestors = getOverflowAncestors(refs.domReference.current);\n      }\n\n      if (isElement(refs.floating.current)) {\n        ancestors = ancestors.concat(getOverflowAncestors(refs.floating.current));\n      }\n\n      if (!isElement(refs.reference.current) && refs.reference.current && // @ts-expect-error is VirtualElement\n      refs.reference.current.contextElement) {\n        ancestors = ancestors.concat( // @ts-expect-error is VirtualElement\n        getOverflowAncestors(refs.reference.current.contextElement));\n      }\n    } // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n\n\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      escapeKey && doc.removeEventListener('keydown', onKeyDown);\n      outsidePress && doc.removeEventListener(outsidePressEvent, onOutsidePress);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n    };\n  }, [escapeKey, outsidePressRef, outsidePressEvent, events, tree, nodeId, open, onOpenChange, ancestorScroll, enabled, bubbles, refs, nested]);\n  React.useEffect(() => {\n    insideReactTreeRef.current = false;\n  }, [outsidePress, outsidePressEvent]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n\n    return {\n      reference: {\n        [bubbleHandlerKeys[referencePressEvent]]: () => {\n          if (referencePress) {\n            events.emit('dismiss', {\n              type: 'referencePress',\n              data: {\n                returnFocus: false\n              }\n            });\n            onOpenChange(false);\n          }\n        }\n      },\n      floating: {\n        [captureHandlerKeys[outsidePressEvent]]: () => {\n          insideReactTreeRef.current = true;\n        }\n      }\n    };\n  }, [enabled, events, referencePress, outsidePressEvent, referencePressEvent, onOpenChange]);\n};\n\n/**\n * Adds focus event listeners that change the open state, like CSS :focus.\n * @see https://floating-ui.com/docs/useFocus\n */\nconst useFocus = function (_ref, _temp) {\n  let {\n    open,\n    onOpenChange,\n    dataRef,\n    refs,\n    events\n  } = _ref;\n  let {\n    enabled = true,\n    keyboardOnly = true\n  } = _temp === void 0 ? {} : _temp;\n  const pointerTypeRef = React.useRef('');\n  const blockFocusRef = React.useRef(false);\n  const timeoutRef = React.useRef();\n  React.useEffect(() => {\n    var _doc$defaultView;\n\n    if (!enabled) {\n      return;\n    }\n\n    const doc = getDocument(refs.floating.current);\n    const win = (_doc$defaultView = doc.defaultView) != null ? _doc$defaultView : window; // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n\n    function onBlur() {\n      if (!open && isHTMLElement(refs.domReference.current) && refs.domReference.current === activeElement(getDocument(refs.domReference.current))) {\n        blockFocusRef.current = true;\n      }\n    }\n\n    win.addEventListener('blur', onBlur);\n    return () => {\n      win.removeEventListener('blur', onBlur);\n    };\n  }, [refs, open, enabled]);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    function onDismiss(payload) {\n      if (payload.type === 'referencePress' || payload.type === 'escapeKey') {\n        blockFocusRef.current = true;\n      }\n    }\n\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [events, enabled]);\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(timeoutRef.current);\n    };\n  }, []);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n\n    return {\n      reference: {\n        onPointerDown(_ref2) {\n          let {\n            pointerType\n          } = _ref2;\n          pointerTypeRef.current = pointerType;\n          blockFocusRef.current = !!(pointerType && keyboardOnly);\n        },\n\n        onMouseLeave() {\n          blockFocusRef.current = false;\n        },\n\n        onFocus(event) {\n          var _dataRef$current$open;\n\n          if (blockFocusRef.current) {\n            return;\n          } // Dismiss with click should ignore the subsequent `focus` trigger,\n          // but only if the click originated inside the reference element.\n\n\n          if (event.type === 'focus' && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === 'mousedown' && dataRef.current.openEvent && isEventTargetWithin(dataRef.current.openEvent, refs.domReference.current)) {\n            return;\n          }\n\n          dataRef.current.openEvent = event.nativeEvent;\n          onOpenChange(true);\n        },\n\n        onBlur(event) {\n          blockFocusRef.current = false;\n          const relatedTarget = event.relatedTarget; // Hit the non-modal focus management portal guard. Focus will be\n          // moved into the floating element immediately after.\n\n          const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute('data-floating-ui-focus-guard'); // Wait for the window blur listener to fire.\n\n          timeoutRef.current = setTimeout(() => {\n            // When focusing the reference element (e.g. regular click), then\n            // clicking into the floating element, prevent it from hiding.\n            // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n            if (contains(refs.floating.current, relatedTarget) || contains(refs.domReference.current, relatedTarget) || movedToFocusGuard) {\n              return;\n            }\n\n            onOpenChange(false);\n          });\n        }\n\n      }\n    };\n  }, [enabled, keyboardOnly, refs, dataRef, onOpenChange]);\n};\n\nlet isPreventScrollSupported = false;\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\n\nfunction isDifferentRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\n\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\n\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  let index = startingIndex;\n\n  do {\n    var _list$index, _list$index2;\n\n    index = index + (decrement ? -amount : amount);\n  } while (index >= 0 && index <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index) : list[index] == null || ((_list$index = list[index]) == null ? void 0 : _list$index.hasAttribute('disabled')) || ((_list$index2 = list[index]) == null ? void 0 : _list$index2.getAttribute('aria-disabled')) === 'true'));\n\n  return index;\n}\n\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n\n    case 'horizontal':\n      return horizontal;\n\n    default:\n      return vertical || horizontal;\n  }\n}\n\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\n\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key == ' ' || key === '';\n}\n\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\n\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\n\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\n\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\n\n/**\n * Adds focus-managed indexed navigation via arrow keys to a list of items\n * within the floating element.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nconst useListNavigation = function (_ref, _temp2) {\n  let {\n    open,\n    onOpenChange,\n    refs\n  } = _ref;\n  let {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    cols = 1\n  } = _temp2 === void 0 ? {\n    listRef: {\n      current: []\n    },\n    activeIndex: null,\n    onNavigate: () => {}\n  } : _temp2;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (allowEscape) {\n      if (!loop) {\n        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));\n      }\n\n      if (!virtual) {\n        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));\n      }\n    }\n\n    if (orientation === 'vertical' && cols > 1) {\n      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either \"horizontal\" or \"both\".'].join(' '));\n    }\n  }\n\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const onNavigate = useEvent(unstable_onNavigate);\n  const focusItemOnOpenRef = React.useRef(focusItemOnOpen);\n  const indexRef = React.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = React.useRef(null);\n  const blockPointerLeaveRef = React.useRef(false);\n  const previousOnNavigateRef = React.useRef(onNavigate);\n  const previousOpenRef = React.useRef(open);\n  const forceSyncFocus = React.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const [activeId, setActiveId] = React.useState();\n  const focusItem = React.useCallback((listRef, indexRef) => {\n    if (virtual) {\n      var _listRef$current$inde;\n\n      setActiveId((_listRef$current$inde = listRef.current[indexRef.current]) == null ? void 0 : _listRef$current$inde.id);\n    } else {\n      const item = listRef.current[indexRef.current];\n      enqueueFocus(item, {\n        preventScroll: true,\n        // Mac Safari does not move the virtual cursor unless the focus call\n        // is sync. However, for the very first focus call, we need to wait\n        // for the position to be ready in order to prevent unwanted\n        // scrolling. This means the virtual cursor will not move to the first\n        // item when first opening the floating element, but will on\n        // subsequent calls. `preventScroll` is supported in modern Safari,\n        // so we can use that instead.\n        // iOS Safari must be async or the first item will not be focused.\n        sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false\n      });\n    }\n  }, [virtual]);\n  index(() => {\n    document.createElement('div').focus({\n      get preventScroll() {\n        isPreventScrollSupported = true;\n        return false;\n      }\n\n    });\n  }, []); // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (open) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        onNavigate(selectedIndex);\n      }\n    } else if (previousOpenRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function\n      indexRef.current = -1;\n      previousOnNavigateRef.current(null);\n    }\n  }, [enabled, open, selectedIndex, onNavigate]); // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (open) {\n      if (activeIndex == null) {\n        forceSyncFocus.current = false;\n\n        if (selectedIndex != null) {\n          return;\n        } // Reset while the floating element was open (e.g. the list changed).\n\n\n        if (previousOpenRef.current) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        } // Initial sync\n\n\n        if (!previousOpenRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n          onNavigate(indexRef.current);\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef);\n      }\n    }\n  }, [enabled, open, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]); // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (previousOpenRef.current && !open) {\n      var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n\n      const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.refs.floating.current;\n\n      if (parentFloating && !contains(parentFloating, activeElement(getDocument(parentFloating)))) {\n        parentFloating.focus({\n          preventScroll: true\n        });\n      }\n    }\n  }, [enabled, open, tree, parentId]);\n  index(() => {\n    keyRef.current = null;\n    previousOnNavigateRef.current = onNavigate;\n    previousOpenRef.current = open;\n  });\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n\n    const disabledIndices = disabledIndicesRef.current;\n\n    function onKeyDown(event) {\n      blockPointerLeaveRef.current = true;\n      forceSyncFocus.current = true; // If the floating element is animating out, ignore navigation. Otherwise,\n      // the `activeIndex` gets set to 0 despite not being open so the next time\n      // the user ArrowDowns, the first item won't be focused.\n\n      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n        return;\n      }\n\n      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n        stopEvent(event);\n        onOpenChange(false);\n\n        if (isHTMLElement(refs.domReference.current)) {\n          refs.domReference.current.focus();\n        }\n\n        return;\n      }\n\n      const currentIndex = indexRef.current;\n      const minIndex = getMinIndex(listRef, disabledIndices);\n      const maxIndex = getMaxIndex(listRef, disabledIndices);\n\n      if (event.key === 'Home') {\n        indexRef.current = minIndex;\n        onNavigate(indexRef.current);\n      }\n\n      if (event.key === 'End') {\n        indexRef.current = maxIndex;\n        onNavigate(indexRef.current);\n      } // Grid navigation\n\n\n      if (cols > 1) {\n        const prevIndex = indexRef.current;\n\n        if (event.key === ARROW_UP) {\n          stopEvent(event);\n\n          if (prevIndex === -1) {\n            indexRef.current = maxIndex;\n          } else {\n            indexRef.current = findNonDisabledIndex(listRef, {\n              startingIndex: prevIndex,\n              amount: cols,\n              decrement: true,\n              disabledIndices\n            });\n\n            if (loop && (prevIndex - cols < minIndex || indexRef.current < 0)) {\n              const col = prevIndex % cols;\n              const maxCol = maxIndex % cols;\n              const offset = maxIndex - (maxCol - col);\n\n              if (maxCol === col) {\n                indexRef.current = maxIndex;\n              } else {\n                indexRef.current = maxCol > col ? offset : offset - cols;\n              }\n            }\n          }\n\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            indexRef.current = prevIndex;\n          }\n\n          onNavigate(indexRef.current);\n        }\n\n        if (event.key === ARROW_DOWN) {\n          stopEvent(event);\n\n          if (prevIndex === -1) {\n            indexRef.current = minIndex;\n          } else {\n            indexRef.current = findNonDisabledIndex(listRef, {\n              startingIndex: prevIndex,\n              amount: cols,\n              disabledIndices\n            });\n\n            if (loop && prevIndex + cols > maxIndex) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex % cols - cols,\n                amount: cols,\n                disabledIndices\n              });\n            }\n          }\n\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            indexRef.current = prevIndex;\n          }\n\n          onNavigate(indexRef.current);\n        } // Remains on the same row/column\n\n\n        if (orientation === 'both') {\n          const prevRow = Math.floor(prevIndex / cols);\n\n          if (event.key === ARROW_RIGHT) {\n            stopEvent(event);\n\n            if (prevIndex % cols !== cols - 1) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                disabledIndices\n              });\n\n              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex - prevIndex % cols - 1,\n                  disabledIndices\n                });\n              }\n            } else if (loop) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex - prevIndex % cols - 1,\n                disabledIndices\n              });\n            }\n\n            if (isDifferentRow(indexRef.current, cols, prevRow)) {\n              indexRef.current = prevIndex;\n            }\n          }\n\n          if (event.key === ARROW_LEFT) {\n            stopEvent(event);\n\n            if (prevIndex % cols !== 0) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                disabledIndices,\n                decrement: true\n              });\n\n              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex + (cols - prevIndex % cols),\n                  decrement: true,\n                  disabledIndices\n                });\n              }\n            } else if (loop) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex + (cols - prevIndex % cols),\n                decrement: true,\n                disabledIndices\n              });\n            }\n\n            if (isDifferentRow(indexRef.current, cols, prevRow)) {\n              indexRef.current = prevIndex;\n            }\n          }\n\n          const lastRow = Math.floor(maxIndex / cols) === prevRow;\n\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            if (loop && lastRow) {\n              indexRef.current = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex - prevIndex % cols - 1,\n                disabledIndices\n              });\n            } else {\n              indexRef.current = prevIndex;\n            }\n          }\n\n          onNavigate(indexRef.current);\n          return;\n        }\n      }\n\n      if (isMainOrientationKey(event.key, orientation)) {\n        stopEvent(event); // Reset the index if no item is focused.\n\n        if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n          onNavigate(indexRef.current);\n          return;\n        }\n\n        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n          if (loop) {\n            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            }));\n          }\n        } else {\n          if (loop) {\n            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            }));\n          }\n        }\n\n        if (isIndexOutOfBounds(listRef, indexRef.current)) {\n          onNavigate(null);\n        } else {\n          onNavigate(indexRef.current);\n        }\n      }\n    }\n\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n\n      if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n\n    return {\n      reference: { ...(virtual && open && activeIndex != null && {\n          'aria-activedescendant': activeId\n        }),\n\n        onKeyDown(event) {\n          blockPointerLeaveRef.current = true;\n          const isArrowKey = event.key.indexOf('Arrow') === 0;\n\n          if (virtual && open) {\n            return onKeyDown(event);\n          } // If a floating element should not open on arrow key down, avoid\n          // setting `activeIndex` while it's closed.\n\n\n          if (!open && !openOnArrowKeyDown && isArrowKey) {\n            return;\n          }\n\n          const isNavigationKey = isArrowKey || event.key === 'Enter' || event.key === ' ' || event.key === '';\n\n          if (isNavigationKey) {\n            keyRef.current = event.key;\n          }\n\n          if (nested) {\n            if (isCrossOrientationOpenKey(event.key, orientation, rtl)) {\n              stopEvent(event);\n\n              if (open) {\n                indexRef.current = getMinIndex(listRef, disabledIndices);\n                onNavigate(indexRef.current);\n              } else {\n                onOpenChange(true);\n              }\n            }\n\n            return;\n          }\n\n          if (isMainOrientationKey(event.key, orientation)) {\n            if (selectedIndex != null) {\n              indexRef.current = selectedIndex;\n            }\n\n            stopEvent(event);\n\n            if (!open && openOnArrowKeyDown) {\n              onOpenChange(true);\n            } else {\n              onKeyDown(event);\n            }\n\n            if (open) {\n              onNavigate(indexRef.current);\n            }\n          }\n        },\n\n        onFocus() {\n          if (open) {\n            onNavigate(null);\n          }\n        },\n\n        onPointerDown: checkVirtualPointer,\n        onMouseDown: checkVirtualMouse,\n        onClick: checkVirtualMouse\n      },\n      floating: {\n        'aria-orientation': orientation === 'both' ? undefined : orientation,\n        ...(virtual && activeIndex != null && {\n          'aria-activedescendant': activeId\n        }),\n        onKeyDown,\n\n        onPointerMove() {\n          blockPointerLeaveRef.current = false;\n        }\n\n      },\n      item: {\n        onFocus(_ref2) {\n          let {\n            currentTarget\n          } = _ref2;\n          const index = listRef.current.indexOf(currentTarget);\n\n          if (index !== -1 && activeIndex !== index) {\n            onNavigate(index);\n          }\n        },\n\n        onClick: _ref3 => {\n          let {\n            currentTarget\n          } = _ref3;\n          return currentTarget.focus({\n            preventScroll: true\n          });\n        },\n        // Safari\n        ...(focusItemOnHover && {\n          onMouseMove(_ref4) {\n            let {\n              currentTarget\n            } = _ref4;\n            const target = currentTarget;\n\n            if (target) {\n              const index = listRef.current.indexOf(target);\n\n              if (index !== -1 && activeIndex !== index) {\n                onNavigate(index);\n              }\n            }\n          },\n\n          onPointerLeave() {\n            if (!blockPointerLeaveRef.current) {\n              indexRef.current = -1;\n              focusItem(listRef, indexRef); // Virtual cursor with VoiceOver on iOS needs this to be flushed\n              // synchronously or there is a glitch that prevents nested\n              // submenus from being accessible.\n\n              flushSync(() => onNavigate(null));\n\n              if (!virtual) {\n                var _refs$floating$curren;\n\n                // This also needs to be sync to prevent fast mouse movements\n                // from leaving behind a stale active item when landing on a\n                // disabled button item.\n                (_refs$floating$curren = refs.floating.current) == null ? void 0 : _refs$floating$curren.focus({\n                  preventScroll: true\n                });\n              }\n            }\n          }\n\n        })\n      }\n    };\n  }, [activeId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, activeIndex, nested, selectedIndex, openOnArrowKeyDown, focusItemOnHover, allowEscape, cols, loop, refs, focusItemOnOpen, focusItem, onNavigate, onOpenChange]);\n};\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nconst useTypeahead = function (_ref, _temp) {\n  var _ref2;\n\n  let {\n    open,\n    dataRef\n  } = _ref;\n  let {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch = () => {},\n    enabled = true,\n    findMatch = null,\n    resetMs = 1000,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = _temp === void 0 ? {\n    listRef: {\n      current: []\n    },\n    activeIndex: null\n  } : _temp;\n  const timeoutIdRef = React.useRef();\n  const stringRef = React.useRef('');\n  const prevIndexRef = React.useRef((_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1);\n  const matchIndexRef = React.useRef(null);\n  const onMatch = useEvent(unstable_onMatch);\n  const findMatchRef = useLatestRef(findMatch);\n  const ignoreKeysRef = useLatestRef(ignoreKeys);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation\n    if (open && stringRef.current === '') {\n      var _ref3;\n\n      prevIndexRef.current = (_ref3 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref3 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n\n    function onKeyDown(event) {\n      // Correctly scope nested non-portalled floating elements. Since the nested\n      // floating element is inside of the another, we find the closest role\n      // that indicates the floating element scope.\n      const target = getTarget(event.nativeEvent);\n\n      if (isElement(target) && (activeElement(getDocument(target)) !== event.currentTarget ? target.closest('[role=\"dialog\"],[role=\"menu\"],[role=\"listbox\"],[role=\"tree\"],[role=\"grid\"]') !== event.currentTarget : false)) {\n        return;\n      }\n\n      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n        dataRef.current.typing = true;\n\n        if (event.key === ' ') {\n          stopEvent(event);\n        }\n      }\n\n      const listContent = listRef.current;\n\n      if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key\n      event.key.length !== 1 || // Modifier key\n      event.ctrlKey || event.metaKey || event.altKey) {\n        return;\n      } // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n      // allow it in this case, too.\n\n\n      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n        var _text$, _text$2;\n\n        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n      }); // Allows the user to cycle through items that start with the same letter\n      // in rapid succession\n\n      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n      }\n\n      stringRef.current += event.key;\n      clearTimeout(timeoutIdRef.current);\n      timeoutIdRef.current = setTimeout(() => {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n        dataRef.current.typing = false;\n      }, resetMs);\n      const prevIndex = prevIndexRef.current;\n      const orderedList = [...listContent.slice((prevIndex != null ? prevIndex : 0) + 1), ...listContent.slice(0, (prevIndex != null ? prevIndex : 0) + 1)];\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, stringRef.current) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(stringRef.current.toLocaleLowerCase())) === 0);\n      const index = str ? listContent.indexOf(str) : -1;\n\n      if (index !== -1) {\n        onMatch(index);\n        matchIndexRef.current = index;\n      }\n    }\n\n    return {\n      reference: {\n        onKeyDown\n      },\n      floating: {\n        onKeyDown\n      }\n    };\n  }, [enabled, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch]);\n};\n\nexport { FloatingDelayGroup, FloatingFocusManager, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, inner, safePolygon, useClick, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInnerOffset, useInteractions, useListNavigation, useRole, useTypeahead };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}